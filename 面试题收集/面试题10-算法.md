# 算法面试题

* [数据结构](#数据结构)
   * [数组跟链表有什么区别？](#数组跟链表有什么区别)
   * [Hash表的实现方式是怎么样的？查询和插入复杂度都是多少？附加：如果插入的时候出现冲突，解决方案？](#hash表的实现方式是怎么样的查询和插入复杂度都是多少附加如果插入的时候出现冲突解决方案)
* [算法：排序](#算法排序)
   * [排序的稳定性](#排序的稳定性)
   * [排序时间复杂度，空间复杂度](#排序时间复杂度空间复杂度)
   * [1、冒泡排序：稳定](#1冒泡排序稳定)
   * [2、选择排序：不稳定](#2选择排序不稳定)
   * [3、快速排序：不稳定](#3快速排序不稳定)
   * [4、插入排序：稳定](#4插入排序稳定)
   * [5、堆排序：不稳定（选择排序的一种）](#5堆排序不稳定选择排序的一种)
* [算法：链表](#算法链表)
   * [1. 求单链表中结点的个数](#1-求单链表中结点的个数)
   * [2. 将单链表反转](#2-将单链表反转)
   * [3. 查找单链表中的倒数第K个结点（k &gt; 0）](#3-查找单链表中的倒数第k个结点k--0)
   * [4. 查找单链表的中间结点](#4-查找单链表的中间结点)
   * [5. 从尾到头打印单链表](#5-从尾到头打印单链表)
   * [6. 已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序](#6-已知两个单链表phead1-和phead2-各自有序把它们合并成一个链表依然有序)
   * [7. 判断一个单链表中是否有环](#7-判断一个单链表中是否有环)
   * [8. 判断两个单链表是否相交](#8-判断两个单链表是否相交)
   * [9. 求两个单链表相交的第一个节点](#9-求两个单链表相交的第一个节点)
   * [10. 已知一个单链表中存在环，求进入环中的第一个节点](#10-已知一个单链表中存在环求进入环中的第一个节点)
   * [11. 给出一单链表头指针pHead和一节点指针pToBeDeleted，O(1)时间复杂度删除节点pToBeDeleted](#11-给出一单链表头指针phead和一节点指针ptobedeletedo1时间复杂度删除节点ptobedeleted)
* [算法：二叉树](#算法二叉树)
   * [0. 树的概念](#0-树的概念)
   * [1. 求二叉树中的节点个数](#1-求二叉树中的节点个数)
   * [2. 求二叉树的深度](#2-求二叉树的深度)
   * [3. 前序遍历，中序遍历，后序遍历](#3-前序遍历中序遍历后序遍历)
      * [3.1 前序遍历递归解法：](#31-前序遍历递归解法)
      * [3.2 中序遍历递归解法](#32-中序遍历递归解法)
      * [3.3 后序遍历递归解法](#33-后序遍历递归解法)
   * [4.分层遍历二叉树（按层次从上往下，从左往右）](#4分层遍历二叉树按层次从上往下从左往右)
   * [5. 将二叉查找树变为有序的双向链表](#5-将二叉查找树变为有序的双向链表)
   * [6. 求二叉树第K层的节点个数](#6-求二叉树第k层的节点个数)
   * [7. 求二叉树中叶子节点的个数](#7-求二叉树中叶子节点的个数)
   * [8. 判断两棵二叉树是否结构相同](#8-判断两棵二叉树是否结构相同)
   * [9. 判断二叉树是不是平衡二叉树](#9-判断二叉树是不是平衡二叉树)
   * [10. 求二叉树的镜像](#10-求二叉树的镜像)
   * [11. 求二叉树中两个节点的最低公共祖先节点](#11-求二叉树中两个节点的最低公共祖先节点)
   * [12. 求二叉树中节点的最大距离](#12-求二叉树中节点的最大距离)
   * [13. 由前序遍历序列和中序遍历序列重建二叉树](#13-由前序遍历序列和中序遍历序列重建二叉树)
   * [14.判断二叉树是不是完全二叉树](#14判断二叉树是不是完全二叉树)
* [算法面试题](#算法面试题-1)
   * [1、将一整数逆序后放入一数组中（要求递归实现）](#1将一整数逆序后放入一数组中要求递归实现)
   * [2、求高于平均分的学生学号及成绩（学号和成绩人工输入）](#2求高于平均分的学生学号及成绩学号和成绩人工输入)
   * [3、递归实现回文判断（如：abcdedbca就是回文，判断一个面试者对递归理解的简单程序）](#3递归实现回文判断如abcdedbca就是回文判断一个面试者对递归理解的简单程序)
   * [4、组合问题（从M个不同字符中任取N个字符的所有组合）](#4组合问题从m个不同字符中任取n个字符的所有组合)
   * [5、分解成质因数(如435234=251<em>17</em>17<em>3</em>2，据说是华为笔试题)](#5分解成质因数如435234251171732据说是华为笔试题)
   * [6、寻找迷宫的一条出路，o：通路； X：障碍。（大家经常谈到的一个小算法题）](#6寻找迷宫的一条出路o通路-x障碍大家经常谈到的一个小算法题)
   * [7、随机分配座位，共50个学生，使学号相邻的同学座位不能相邻(早些时候用C#写的，没有用C改写）。](#7随机分配座位共50个学生使学号相邻的同学座位不能相邻早些时候用c写的没有用c改写)
   * [8、求网格中的黑点分布。现有6*7的网格，在某些格子中有黑点，已知各行与各列中有黑点的点数之和，请在这张网格中画出黑点的位置。（这是一网友提出的题目，说是他笔试时遇到算法题）](#8求网格中的黑点分布现有67的网格在某些格子中有黑点已知各行与各列中有黑点的点数之和请在这张网格中画出黑点的位置这是一网友提出的题目说是他笔试时遇到算法题)
   * [9、有4种面值的邮票很多枚，这4种邮票面值分别1, 4, 12, 21，现从多张中最多任取5张进行组合，求取出这些邮票的最大连续组合值。（据说是华为2003年校园招聘笔试题）](#9有4种面值的邮票很多枚这4种邮票面值分别1-4-12-21现从多张中最多任取5张进行组合求取出这些邮票的最大连续组合值据说是华为2003年校园招聘笔试题)
   * [10、大整数数相乘的问题。（这是2002年在一考研班上遇到的算法题）](#10大整数数相乘的问题这是2002年在一考研班上遇到的算法题)
   * [11、求最大连续递增数字串（如“ads3sl456789DF3456ld345AA”中的“456789”）](#11求最大连续递增数字串如ads3sl456789df3456ld345aa中的456789)
   * [12、四个工人，四个任务，每个人做不同的任务需要的时间不同，求任务分配的最优方案。（2005年5月29日全国计算机软件资格水平考试——软件设计师的算法题）。](#12四个工人四个任务每个人做不同的任务需要的时间不同求任务分配的最优方案2005年5月29日全国计算机软件资格水平考试软件设计师的算法题)
   * [13、八皇后问题，输出了所有情况，不过有些结果只是旋转了90度而已。（回溯算法的典型例题，是数据结构书上算法的具体实现，大家都亲自动手写过这个程序吗？）](#13八皇后问题输出了所有情况不过有些结果只是旋转了90度而已回溯算法的典型例题是数据结构书上算法的具体实现大家都亲自动手写过这个程序吗)
   * [14、实现strstr功能，即在父串中寻找子串首次出现的位置。（笔试中常让面试者实现标准库中的一些函数）](#14实现strstr功能即在父串中寻找子串首次出现的位置笔试中常让面试者实现标准库中的一些函数)
   * [15、现在小明一家过一座桥，过桥的时候是黑夜，所以必须有灯。现在小明过桥要1分，小明的弟弟要3分，小明的爸爸要6分，小明的妈妈要8分，小明的爷爷要12分。每次此桥最多可过两人，而过桥的速度依过桥最慢者而定，而且灯在点燃后30分就会熄灭。问小明一家如何过桥时间最短？（原本是个小小智力题，据说是外企的面试题，在这里用程序来求解）](#15现在小明一家过一座桥过桥的时候是黑夜所以必须有灯现在小明过桥要1分小明的弟弟要3分小明的爸爸要6分小明的妈妈要8分小明的爷爷要12分每次此桥最多可过两人而过桥的速度依过桥最慢者而定而且灯在点燃后30分就会熄灭问小明一家如何过桥时间最短原本是个小小智力题据说是外企的面试题在这里用程序来求解)
   * [16、2005年11月金山笔试题。编码完成下面的处理函数。函数将字符串中的字符'<em>'移到串的前部分，前面的非'</em>'字符后移，但不能改变非'<em>'字符的先后顺序，函数返回串中字符'</em>'的数量。如原始串为：ab<strong>cd</strong>e*12，处理后为*****abcde12，函数并返回值为5。（要求使用尽量少的时间和辅助空间）](#162005年11月金山笔试题编码完成下面的处理函数函数将字符串中的字符移到串的前部分前面的非字符后移但不能改变非字符的先后顺序函数返回串中字符的数量如原始串为abcde12处理后为abcde12函数并返回值为5要求使用尽量少的时间和辅助空间)
   * [17、2005年11月15日华为软件研发笔试题。实现一单链表的逆转。](#172005年11月15日华为软件研发笔试题实现一单链表的逆转)
   * [18、编码实现字符串转整型的函数（实现函数atoi的功能），据说是神州数码笔试题。如将字符串 ” 123”123, ”-0123”-123, “123CS45”123, “123.45CS”123, “CS123.45”0](#18编码实现字符串转整型的函数实现函数atoi的功能据说是神州数码笔试题如将字符串-123123--0123-123-123cs45123-12345cs123-cs123450)
   * [19、歌德巴赫猜想。任何一个偶数都可以分解为两个素数之和。（其实这是个C二级考试的模拟试题）](#19歌德巴赫猜想任何一个偶数都可以分解为两个素数之和其实这是个c二级考试的模拟试题)
   * [20、快速排序（东软喜欢考类似的算法填空题，又如堆排序的算法等）](#20快速排序东软喜欢考类似的算法填空题又如堆排序的算法等)
   * [21、2005年11月23日慧通笔试题：写一函数判断某个整数是否为回文数，如12321为回文数。可以用判断入栈和出栈是否相同来实现（略微复杂些），这里是将整数逆序后形成另一整数，判断两个整数是否相等来实现的。](#212005年11月23日慧通笔试题写一函数判断某个整数是否为回文数如12321为回文数可以用判断入栈和出栈是否相同来实现略微复杂些这里是将整数逆序后形成另一整数判断两个整数是否相等来实现的)
   * [22、删除字符串中的数字并压缩字符串（神州数码以前笔试题），如字符串”abc123de4fg56”处理后变为”abcdefg”。注意空间和效率。（下面的算法只需要一次遍历，不需要开辟新空间，时间复杂度为O(N)）](#22删除字符串中的数字并压缩字符串神州数码以前笔试题如字符串abc123de4fg56处理后变为abcdefg注意空间和效率下面的算法只需要一次遍历不需要开辟新空间时间复杂度为on)
   * [23、求两个串中的第一个最长子串（神州数码以前试题）。如"abractyeyt","dgdsaeactyey"的最大子串为"actyet"。](#23求两个串中的第一个最长子串神州数码以前试题如abractyeytdgdsaeactyey的最大子串为actyet)
   * [24、不开辟用于交换数据的临时空间，如何完成字符串的逆序 (在技术一轮面试中，有些面试官会这样问)](#24不开辟用于交换数据的临时空间如何完成字符串的逆序-在技术一轮面试中有些面试官会这样问)
   * [25、删除串中指定的字符（做此题时，千万不要开辟新空间，否则面试官可能认为你不适合做嵌入式开发）](#25删除串中指定的字符做此题时千万不要开辟新空间否则面试官可能认为你不适合做嵌入式开发)
   * [26、判断单链表中是否存在环（网上说的笔试题）](#26判断单链表中是否存在环网上说的笔试题)

## 数据结构

面试总体上分为计算机网络，数据结构，OC基础和算法。

### 数组跟链表有什么区别？

1. 存储空间：数组存栈，链表放堆。
2. 开辟模式：
    1. 数组需要预先开辟一块空间。如果使用不满会有浪费。对动态数组而言，存放数据超出空间会另外申请开辟。
    2. 链表属于动态存储，内存不一定连续。
3. 增删改查
    1. 数组：查询更快，下标索引。
    2. 链表：增删效率高些，因为只需要操作一下指针

### Hash表的实现方式是怎么样的？查询和插入复杂度都是多少？附加：如果插入的时候出现冲突，解决方案？

Hash表应该也算数据结构里面一个比较基础的类型了。

大致的实现为，Hash表会根据Hash函数为每个value计算一个hash值，然后用这个hash值/表空间大小，余数就是当前对象放的位置了。这个时候问题就来了，满了咋办？位置上有别的东西了咋办呢…这就需要冲突解决方案了。一般来说有：线性探测（比如0上有元素了，我往后挪1个看看有没有，往后挪2个有没有之类的），跳跃型探测（左右闪躲啊有木有，比如+11，-11，+21，-21……），拉链法（等于变成了个二维结构）。

查询插入复杂度都是1。一步到位。

## 算法：排序

### 排序的稳定性

**排序的稳定**是指如果存在相同的元素，在排序前后如果位置没有发生改变，那就是稳定的排序，否则就是不稳定的排序。

### 排序时间复杂度，空间复杂度

**时间复杂度（Time complexity）** 

* 1、算法中的语句执行次数为一个常数，则时间复杂度为O(1)
* 2、时间复杂度只关注最高数量级

**空间复杂度（Space Complexity）**

* 1、只要算法不涉及到动态分配的空间以及递归、栈所需的空间，空间复杂度通常为O(1)
* 2、算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。

![](https://image-1258017831.cos.ap-guangzhou.myqcloud.com/20181121080253.png)

[最详细的解说—时间和空间复杂度](https://www.jianshu.com/p/1ac6ad4069f8)
[八大排序算法总结&时间复杂度&稳定性](https://blog.csdn.net/feizxiang3/article/details/8198362)

### 1、冒泡排序：稳定
对要排序的数据，从上到下依次比较两个相邻的数并加以调整，将最大的数向下移动，较小的数向上冒起。即：每一趟依次比较相邻的两个数据元素，将较小的数放在左边，循环进行同样的操作，直到全部待排序的数据元素排完。

```
for(i=0;i<10;i++) {
    for(j=i;j<10;j++) {
        if(num[j]<num[i]){
            k=num[j];
            num[j] = num[i];
            num[i] = k;
        }
    }
}
```

### 2、选择排序：不稳定

它的工作原理如下，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
口语化描述：一趟下来先找第一小，再来一趟再找第二小！

1、算法思想：
将待排序序列分为两部分，一部分为有序序列，另一部分为无序序列。第一趟：从a[0]到a[n-1]中找到最小的数a[i]，然后将a[i]与a[0]交换，第二趟：从a[1]到a[n-1]中找到最小的数a[j]，然后将a[j]与a[1]交换,第三趟：从a[2]到a[n-1]中找到最小的数a[k],然后将a[k]与a[2]交换 ……
2、实例分析：
  {13,15,37,89,60,39,12,109,56,72}
   第一趟 ：12  {15,37,89,60,39,13,109,56,72}
   第二趟：12 ，13 {37,89,60,39,15,109,56,72}
   第三趟：12 ，13 ，15 {89,60,39,37,109,56,72}
     
```
for(i=0; i<10; i++) {
    int temp
    int post = i;
    for(j=i+1; j<10; j++) {
        if(num[j] < num[post]) {
            post=j;
        }
 
        if(post != i) {
            temp = num[i] ;
            num[i] = num[post];
            num[post] = temp;
        }
    }
}     
```

### 3、快速排序：不稳定
它采用了一种分治的策略，分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。

```
- (void)quickSortArray:(NSInteger)left right:(NSInteger)right {
    
    NSInteger i, j, t, temp;
    if (left > right)
        return;
   
    temp = (NSInteger)self.a[left];
    i = left;
    j = right;
   
    while (i != j) {
        
        //从右边开始遍历
        while ((NSInteger)self.a[j] >= temp && i < j) {
            j--;
        }
        while ((NSInteger)self.a[i] <= temp && i < j) {
            i++;
        }
       
        if (i < j) {
            //t = (NSInteger)self.a[i];
            //self.a[i] = self.a[j];
            //self.a[j] = @(t);
        }
    }
    
    //这个时候 i 已经等于  j 了
    // a[left] = a[i]
    // a [i] = temp
    
    [self quickSortArray:left  right:i-1];
    [self quickSortArray:i+1 right:right];
}
```

### 4、插入排序：稳定

插入排序包括：直接插入排序、二分插入排序以及希尔排序。

**算法思想：**

1〉从第一个元素开始，该元素可以认为已经被排序
2〉取出第一个未排序元素存放在临时变量temp中，在已经排序的元素序列中从后往前扫描，逐一比较
3〉如果temp小于已排序元素，将该元素移到下个位置
4〉重复步骤3〉，直到找到已排序的元素小于或者等于

```
public static int[] insertSort(int[] ary){
    //n-1此扫描，依次向前插入n-1个元素
    for(int i = 1; i < ary.length; i++){
	   int temp = ary[i];
		int j;
		for(j = i-1; j>=0 && temp < ary[j]; j--){
			ary[j+1] = ary[j];//将前面较大的元素向后移动
		}
		ary[j+1] = temp;//temp值到达插入位置
	}
	return ary;
}
```

### 5、堆排序：不稳定（选择排序的一种）

**堆**是具有以下性质的**完全二叉树**：
**大顶堆：**每个结点的值都大于或等于其左右孩子结点的值；
**小顶堆：**每个结点的值都小于或等于其左右孩子结点的值；

堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。

**堆排序的基本思想是：**将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了

一般升序采用大顶堆，降序采用小顶堆

[图解排序算法(三)之堆排序](https://www.cnblogs.com/chengxiao/p/6129630.html)

## 算法：链表

[轻松搞定面试中的链表题目](http://blog.csdn.net/walkinginthewind/article/details/7393134)

链表是最基本的数据结构，面试官也常常用链表来考察面试者的基本能力，而且链表相关的操作相对而言比较简单，也适合考察写代码的能力。链表的操作也离不开指针，指针又很容易导致出错。综合多方面的原因，链表题目在面试中占据着很重要的地位。本文对链表相关的面试题做了较为全面的整理，希望能对找工作的同学有所帮助。

链表结点声明如下：

```
struct ListNode
{
    int m_nKey;
    ListNode * m_pNext;
};
```

### 1. 求单链表中结点的个数

这是最最基本的了，应该能够迅速写出正确的代码，注意检查链表是否为空。
时间复杂度为O（n）。参考代码如下：

```
// 求单链表中结点的个数
unsigned int GetListLength(ListNode * pHead)
{
	if(pHead == NULL)
		return 0;

	unsigned int nLength = 0;
	ListNode * pCurrent = pHead;
	while(pCurrent != NULL)
	{
		nLength++;
		pCurrent = pCurrent->m_pNext;
	}
	return nLength;
}
```

### 2. 将单链表反转

从头到尾遍历原链表，每遍历一个结点，将其摘下放在新链表的最前端。注意链表为空和只有一个结点的情况。
时间复杂度为O（n）。参考代码如下：

```
//方法一：递归方式
void reverse(struct list_node *head)
{
    if(NULL == head || NULL == head->next)
        return;
    reverse1(head->next);
    head->next->next = head;
    head->next = NULL;
}

//方法二：非递归方式反转单链表
ListNode * ReverseList(ListNode * pHead)
{
   // 如果链表为空或只有一个结点，无需反转，直接返回原链表头指针
	if(pHead == NULL || pHead->m_pNext == NULL)  
		return pHead;

	ListNode * pReversedHead = NULL; // 反转后的新链表头指针，初始为NULL
	ListNode * pCurrent = pHead;
	while(pCurrent != NULL)
	{
		ListNode * pTemp = pCurrent;
		pCurrent = pCurrent->m_pNext;
		pTemp->m_pNext = pReversedHead; // 将当前结点摘下，插入新链表的最前端
		pReversedHead = pTemp;
	}
	return pReversedHead;
}
```

### 3. 查找单链表中的倒数第K个结点（k > 0）
最普遍的方法是，先统计单链表中结点的个数，然后再找到第（n-k）个结点。注意链表为空，k为0，k为1，k大于链表中节点个数时的情况。时间复杂度为O（n）。代码略。

这里主要讲一下另一个思路，这种思路在其他题目中也会有应用。

主要思路就是使用两个指针，先让前面的指针走到正向第k个结点，这样前后两个指针的距离差是k-1，之后前后两个指针一起向前走，前面的指针走到最后一个结点时，后面指针所指结点就是倒数第k个结点。

参考代码如下：

```
// 查找单链表中倒数第K个结点
ListNode * RGetKthNode(ListNode * pHead, unsigned int k) // 函数名前面的R代表反向
{
	if(k == 0 || pHead == NULL) // 这里k的计数是从1开始的，若k为0或链表为空返回NULL
		return NULL;

	ListNode * pAhead = pHead;
	ListNode * pBehind = pHead;
	while(k > 1 && pAhead != NULL) // 前面的指针先走到正向第k个结点
	{
		pAhead = pAhead->m_pNext;
		k--;
	}
	if(k > 1 || pAhead == NULL)     // 结点个数小于k，返回NULL
		return NULL;
	while(pAhead->m_pNext != NULL)  // 前后两个指针一起向前走，直到前面的指针指向最后一个结点
	{
		pBehind = pBehind->m_pNext;
		pAhead = pAhead->m_pNext;
	}
	return pBehind;  // 后面的指针所指结点就是倒数第k个结点
}
```

### 4. 查找单链表的中间结点
此题可应用于上一题类似的思想。也是设置两个指针，只不过这里是，两个指针同时向前走，前面的指针每次走两步，后面的指针每次走一步，前面的指针走到最后一个结点时，后面的指针所指结点就是中间结点，即第（n/2+1）个结点。注意链表为空，链表结点个数为1和2的情况。时间复杂度O（n）。参考代码如下：

```
// 获取单链表中间结点，若链表长度为n(n>0)，则返回第n/2+1个结点
ListNode * GetMiddleNode(ListNode * pHead)
{
	if(pHead == NULL || pHead->m_pNext == NULL) // 链表为空或只有一个结点，返回头指针
		return pHead;

	ListNode * pAhead = pHead;
	ListNode * pBehind = pHead;
	while(pAhead->m_pNext != NULL) // 前面指针每次走两步，直到指向最后一个结点，后面指针每次走一步
	{
		pAhead = pAhead->m_pNext;
		pBehind = pBehind->m_pNext;
		if(pAhead->m_pNext != NULL)
			pAhead = pAhead->m_pNext;
	}
	return pBehind; // 后面的指针所指结点即为中间结点
}
```

### 5. 从尾到头打印单链表
对于这种颠倒顺序的问题，我们应该就会想到栈，后进先出。所以，这一题要么自己使用栈，要么让系统使用栈，也就是递归。注意链表为空的情况。时间复杂度为O（n）。参考代码如下：

自己使用栈：

```
// 从尾到头打印链表，使用栈
void RPrintList(ListNode * pHead)
{
	std::stack<ListNode *> s;
	ListNode * pNode = pHead;
	while(pNode != NULL)
	{
		s.push(pNode);
		pNode = pNode->m_pNext;
	}
	while(!s.empty())
	{
		pNode = s.top();
		printf("%d\t", pNode->m_nKey);
		s.pop();
	}
}

```

使用递归函数：

```
// 从尾到头打印链表，使用递归
void RPrintList(ListNode * pHead)
{
	if(pHead == NULL)
	{
		return;
	}
	else
	{
		RPrintList(pHead->m_pNext);
		printf("%d\t", pHead->m_nKey);
	}
}
```

### 6. 已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序

这个类似归并排序。尤其注意两个链表都为空，和其中一个为空时的情况。只需要O（1）的空间。时间复杂度为O（max(len1, len2)）。参考代码如下：

```
// 合并两个有序链表
ListNode * MergeSortedList(ListNode * pHead1, ListNode * pHead2)
{
	if(pHead1 == NULL)
		return pHead2;
	if(pHead2 == NULL)
		return pHead1;
	ListNode * pHeadMerged = NULL;
	if(pHead1->m_nKey < pHead2->m_nKey)
	{
		pHeadMerged = pHead1;
		pHeadMerged->m_pNext = NULL;
		pHead1 = pHead1->m_pNext;
	}
	else
	{
		pHeadMerged = pHead2;
		pHeadMerged->m_pNext = NULL;
		pHead2 = pHead2->m_pNext;
	}
	ListNode * pTemp = pHeadMerged;
	while(pHead1 != NULL && pHead2 != NULL)
	{
		if(pHead1->m_nKey < pHead2->m_nKey)
		{
			pTemp->m_pNext = pHead1;
			pHead1 = pHead1->m_pNext;
			pTemp = pTemp->m_pNext;
			pTemp->m_pNext = NULL;
		}
		else
		{
			pTemp->m_pNext = pHead2;
			pHead2 = pHead2->m_pNext;
			pTemp = pTemp->m_pNext;
			pTemp->m_pNext = NULL;
		}
	}
	if(pHead1 != NULL)
		pTemp->m_pNext = pHead1;
	else if(pHead2 != NULL)
		pTemp->m_pNext = pHead2;
	return pHeadMerged;
}
```

也有如下递归解法：

```
ListNode * MergeSortedList(ListNode * pHead1, ListNode * pHead2)
{
	if(pHead1 == NULL)
		return pHead2;
	if(pHead2 == NULL)
		return pHead1;
	ListNode * pHeadMerged = NULL;
	if(pHead1->m_nKey < pHead2->m_nKey)
	{
		pHeadMerged = pHead1;
		pHeadMerged->m_pNext = MergeSortedList(pHead1->m_pNext, pHead2);
	}
	else
	{
		pHeadMerged = pHead2;
		pHeadMerged->m_pNext = MergeSortedList(pHead1, pHead2->m_pNext);
	}
	return pHeadMerged;
}
```

### 7. 判断一个单链表中是否有环
这里也是用到两个指针。如果一个链表中有环，也就是说用一个指针去遍历，是永远走不到头的。因此，我们可以用两个指针去遍历，一个指针一次走两步，一个指针一次走一步，如果有环，两个指针肯定会在环中相遇。时间复杂度为O（n）。参考代码如下：

```
bool HasCircle(ListNode * pHead)
{
	ListNode * pFast = pHead; // 快指针每次前进两步
	ListNode * pSlow = pHead; // 慢指针每次前进一步
	while(pFast != NULL && pFast->m_pNext != NULL)
	{
		pFast = pFast->m_pNext->m_pNext;
		pSlow = pSlow->m_pNext;
		if(pSlow == pFast) // 相遇，存在环
			return true;
	}
	return false;
}
```

### 8. 判断两个单链表是否相交
如果两个链表相交于某一节点，那么在这个相交节点之后的所有节点都是两个链表所共有的。也就是说，如果两个链表相交，那么最后一个节点肯定是共有的。先遍历第一个链表，记住最后一个节点，然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则不相交。时间复杂度为O(len1+len2)，因为只需要一个额外指针保存最后一个节点地址，空间复杂度为O(1)。参考代码如下：

```
bool IsIntersected(ListNode * pHead1, ListNode * pHead2)
{
        if(pHead1 == NULL || pHead2 == NULL)
                return false;

	ListNode * pTail1 = pHead1;
	while(pTail1->m_pNext != NULL)
		pTail1 = pTail1->m_pNext;

	ListNode * pTail2 = pHead2;
	while(pTail2->m_pNext != NULL)
		pTail2 = pTail2->m_pNext;
	return pTail1 == pTail2;
}
```

### 9. 求两个单链表相交的第一个节点
对第一个链表遍历，计算长度len1，同时保存最后一个节点的地址。
对第二个链表遍历，计算长度len2，同时检查最后一个节点是否和第一个链表的最后一个节点相同，若不相同，不相交，结束。
两个链表均从头节点开始，假设len1大于len2，那么将第一个链表先遍历len1-len2个节点，此时两个链表当前节点到第一个相交节点的距离就相等了，然后一起向后遍历，知道两个节点的地址相同。
时间复杂度，O(len1+len2)。参考代码如下：

```
ListNode* GetFirstCommonNode(ListNode * pHead1, ListNode * pHead2)
{
	if(pHead1 == NULL || pHead2 == NULL)
		return NULL;

	int len1 = 1;
	ListNode * pTail1 = pHead1;
	while(pTail1->m_pNext != NULL)
	{
		pTail1 = pTail1->m_pNext;
		len1++;
	}

	int len2 = 1;
	ListNode * pTail2 = pHead2;
	while(pTail2->m_pNext != NULL)
	{
		pTail2 = pTail2->m_pNext;
		len2++;
	}

	if(pTail1 != pTail2) // 不相交直接返回NULL
		return NULL;

	ListNode * pNode1 = pHead1;
	ListNode * pNode2 = pHead2;
        // 先对齐两个链表的当前结点，使之到尾节点的距离相等
	if(len1 > len2)
	{
		int k = len1 - len2;
		while(k--)
			pNode1 = pNode1->m_pNext;
	}
	else
	{
		int k = len2 - len1;
		while(k--)
			pNode2 = pNode2->m_pNext;
	}
	while(pNode1 != pNode2)
	{
		pNode1 = pNode1->m_pNext;
		pNode2 = pNode2->m_pNext;
	}
        return pNode1;
}
```

### 10. 已知一个单链表中存在环，求进入环中的第一个节点
首先判断是否存在环，若不存在结束。其次在环中的一个节点处断开（当然函数结束时不能破坏原链表），这样就形成了两个相交的单链表，求进入环中的第一个节点也就转换成了求两个单链表相交的第一个节点。参考代码如下：

```
ListNode* GetFirstNodeInCircle(ListNode * pHead)
{
	if(pHead == NULL || pHead->m_pNext == NULL)
		return NULL;

	ListNode * pFast = pHead;
	ListNode * pSlow = pHead;
	while(pFast != NULL && pFast->m_pNext != NULL)
	{
		pSlow = pSlow->m_pNext;
		pFast = pFast->m_pNext->m_pNext;
		if(pSlow == pFast)
			break;
	}
	if(pFast == NULL || pFast->m_pNext == NULL)
		return NULL;

	// 将环中的此节点作为假设的尾节点，将它变成两个单链表相交问题
	ListNode * pAssumedTail = pSlow; 
	ListNode * pHead1 = pHead;
	ListNode * pHead2 = pAssumedTail->m_pNext;

	ListNode * pNode1, * pNode2;
	int len1 = 1;
	ListNode * pNode1 = pHead1;
	while(pNode1 != pAssumedTail)
	{
		pNode1 = pNode1->m_pNext;
		len1++;
	}
	
	int len2 = 1;
	ListNode * pNode2 = pHead2;
	while(pNode2 != pAssumedTail)
	{
		pNode2 = pNode2->m_pNext;
		len2++;
	}

	pNode1 = pHead1;
	pNode2 = pHead2;
	// 先对齐两个链表的当前结点，使之到尾节点的距离相等
	if(len1 > len2)
	{
		int k = len1 - len2;
		while(k--)
			pNode1 = pNode1->m_pNext;
	}
	else
	{
		int k = len2 - len1;
		while(k--)
			pNode2 = pNode2->m_pNext;
	}
	while(pNode1 != pNode2)
	{
		pNode1 = pNode1->m_pNext;
		pNode2 = pNode2->m_pNext;
	}
    return pNode1;
}
```

### 11. 给出一单链表头指针pHead和一节点指针pToBeDeleted，O(1)时间复杂度删除节点pToBeDeleted
对于删除节点，我们普通的思路就是让该节点的前一个节点指向该节点的下一个节点，这种情况需要遍历找到该节点的前一个节点，时间复杂度为O(n)。对于链表，链表中的每个节点结构都是一样的，所以我们可以把该节点的下一个节点的数据复制到该节点，然后删除下一个节点即可。要注意最后一个节点的情况，这个时候只能用常见的方法来操作，先找到前一个节点，但总体的平均时间复杂度还是O(1)。参考代码如下：

```
void Delete(ListNode * pHead, ListNode * pToBeDeleted)
{
	if(pToBeDeleted == NULL)
		return;
	if(pToBeDeleted->m_pNext != NULL)
	{
 	   //将下一个节点的数据复制到本节点，然后删除下一个节点
		pToBeDeleted->m_nKey = pToBeDeleted->m_pNext->m_nKey; 
		ListNode * temp = pToBeDeleted->m_pNext;
		pToBeDeleted->m_pNext = pToBeDeleted->m_pNext->m_pNext;
		delete temp;
	}
	else // 要删除的是最后一个节点
	{
		if(pHead == pToBeDeleted) // 链表中只有一个节点的情况
		{
			pHead = NULL;
			delete pToBeDeleted;
		}
		else
		{
			ListNode * pNode = pHead;
			while(pNode->m_pNext != pToBeDeleted) // 找到倒数第二个节点
				pNode = pNode->m_pNext;
			pNode->m_pNext = NULL;
			delete pToBeDeleted;
		}	
	}
}
```

## 算法：二叉树

[轻松搞定面试中的二叉树题目](https://blog.csdn.net/luckyxiaoqiang/article/details/7518888)

### 0. 树的概念

树是一种比较重要的数据结构，尤其是二叉树。二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。二叉树是递归定义的，因此，与二叉树有关的题目基本都可以用递归思想解决，当然有些题目非递归解法也应该掌握，如非递归遍历节点等等。本文努力对二叉树相关题目做一个较全的整理总结，希望对找工作的同学有所帮助。
二叉树节点定义如下：

```
struct BinaryTreeNode
{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};
```

### 1. 求二叉树中的节点个数
递归解法：
（1）如果二叉树为空，节点个数为0
（2）如果二叉树不为空，二叉树节点个数 = 左子树节点个数 + 右子树节点个数 + 1
参考代码如下：

```
int GetNodeNum(BinaryTreeNode * pRoot)
{
	if(pRoot == NULL) // 递归出口
		return 0;
	return GetNodeNum(pRoot->m_pLeft) + GetNodeNum(pRoot->m_pRight) + 1;
}
```

### 2. 求二叉树的深度
递归解法：
（1）如果二叉树为空，二叉树的深度为0
（2）如果二叉树不为空，二叉树的深度 = max(左子树深度， 右子树深度) + 1
参考代码如下： 

```
int GetDepth(BinaryTreeNode * pRoot)
{
	if(pRoot == NULL) // 递归出口
		return 0;
	int depthLeft = GetDepth(pRoot->m_pLeft);
	int depthRight = GetDepth(pRoot->m_pRight);
	return depthLeft > depthRight ? (depthLeft + 1) : (depthRight + 1); 
}
```

### 3. 前序遍历，中序遍历，后序遍历

前序、中序、后序遍历都是相对根节点来说的！

#### 3.1 前序遍历递归解法：
（1）如果二叉树为空，空操作
（2）如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树
参考代码如下：

```
void PreOrderTraverse(BinaryTreeNode * pRoot)
{
	if(pRoot == NULL)
		return;
	Visit(pRoot); // 访问根节点
	PreOrderTraverse(pRoot->m_pLeft); // 前序遍历左子树
	PreOrderTraverse(pRoot->m_pRight); // 前序遍历右子树
}
```

#### 3.2 中序遍历递归解法
（1）如果二叉树为空，空操作。
（2）如果二叉树不为空，中序遍历左子树，访问根节点，中序遍历右子树
参考代码如下：

```
void InOrderTraverse(BinaryTreeNode * pRoot)
{
	if(pRoot == NULL)
		return;
	InOrderTraverse(pRoot->m_pLeft); // 中序遍历左子树
	Visit(pRoot); // 访问根节点
	InOrderTraverse(pRoot->m_pRight); // 中序遍历右子树
}
```

#### 3.3 后序遍历递归解法
（1）如果二叉树为空，空操作
（2）如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根节点
参考代码如下：

```
void PostOrderTraverse(BinaryTreeNode * pRoot)
{
	if(pRoot == NULL)
		return;
	PostOrderTraverse(pRoot->m_pLeft); // 后序遍历左子树
	PostOrderTraverse(pRoot->m_pRight); // 后序遍历右子树
	Visit(pRoot); // 访问根节点
}
```

### 4.分层遍历二叉树（按层次从上往下，从左往右）
相当于广度优先搜索，使用队列实现。队列初始化，将根节点压入队列。
当队列不为空，进行如下操作：
（1）弹出一个节点，访问
（2）若左子节点或右子节点不为空，将其压入队列。

```
void LevelTraverse(BinaryTreeNode * pRoot)
{
	if(pRoot == NULL)
		return;
	queue<BinaryTreeNode *> q;
	q.push(pRoot);
	while(!q.empty())
	{
		BinaryTreeNode * pNode = q.front();
		q.pop();
		Visit(pNode); // 访问节点
		if(pNode->m_pLeft != NULL)
			q.push(pNode->m_pLeft);
		if(pNode->m_pRight != NULL)
			q.push(pNode->m_pRight);
	}
	return;
}
```

### 5. 将二叉查找树变为有序的双向链表

要求不能创建新节点，只调整指针。
递归解法：
（1）如果二叉树查找树为空，不需要转换，对应双向链表的第一个节点是NULL，最后一个节点是NULL
（2）如果二叉查找树不为空：
如果左子树为空，对应双向有序链表的第一个节点是根节点，左边不需要其他操作；
如果左子树不为空，转换左子树，二叉查找树对应双向有序链表的第一个节点就是左子树转换后双向有序链表的第一个节点，同时将根节点和左子树转换后的双向有序链 表的最后一个节点连接；
如果右子树为空，对应双向有序链表的最后一个节点是根节点，右边不需要其他操作；
如果右子树不为空，对应双向有序链表的最后一个节点就是右子树转换后双向有序链表的最后一个节点，同时将根节点和右子树转换后的双向有序链表的第一个节点连 接。
参考代码如下：

```
/******************************************************************************
参数：
pRoot: 二叉查找树根节点指针
pFirstNode: 转换后双向有序链表的第一个节点指针
pLastNode: 转换后双向有序链表的最后一个节点指针
******************************************************************************/
void Convert(BinaryTreeNode * pRoot, 
             BinaryTreeNode * & pFirstNode, BinaryTreeNode * & pLastNode)
{
	BinaryTreeNode *pFirstLeft, *pLastLeft, * pFirstRight, *pLastRight;
	if(pRoot == NULL) 
	{
		pFirstNode = NULL;
		pLastNode = NULL;
		return;
	}

	if(pRoot->m_pLeft == NULL)
	{
		// 如果左子树为空，对应双向有序链表的第一个节点是根节点
		pFirstNode = pRoot;
	}
	else
	{
		Convert(pRoot->m_pLeft, pFirstLeft, pLastLeft);
		// 二叉查找树对应双向有序链表的第一个节点就是左子树转换后双向有序链表的第一个节点
		pFirstNode = pFirstLeft;
		// 将根节点和左子树转换后的双向有序链表的最后一个节点连接
		pRoot->m_pLeft = pLastLeft;
		pLastLeft->m_pRight = pRoot;
	}

	if(pRoot->m_pRight == NULL)
	{
		// 对应双向有序链表的最后一个节点是根节点
		pLastNode = pRoot;
	}
	else
	{
		Convert(pRoot->m_pRight, pFirstRight, pLastRight);
		// 对应双向有序链表的最后一个节点就是右子树转换后双向有序链表的最后一个节点
		pLastNode = pLastRight;
		// 将根节点和右子树转换后的双向有序链表的第一个节点连接
		pRoot->m_pRight = pFirstRight;
		pFirstRight->m_pLeft = pRoot;
	}

	return;
}
```

### 6. 求二叉树第K层的节点个数
递归解法：
（1）如果二叉树为空或者k<1返回0
（2）如果二叉树不为空并且k==1，返回1
（3）如果二叉树不为空且k>1，返回左子树中k-1层的节点个数与右子树k-1层节点个数之和
参考代码如下：

```
int GetNodeNumKthLevel(BinaryTreeNode * pRoot, int k)
{
	if(pRoot == NULL || k < 1)
		return 0;
	if(k == 1)
		return 1;
	int numLeft = GetNodeNumKthLevel(pRoot->m_pLeft, k-1); // 左子树中k-1层的节点个数
	int numRight = GetNodeNumKthLevel(pRoot->m_pRight, k-1); // 右子树中k-1层的节点个数
	return (numLeft + numRight);
}
```

### 7. 求二叉树中叶子节点的个数
递归解法：
（1）如果二叉树为空，返回0
（2）如果二叉树不为空且左右子树为空，返回1
（3）如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子节点个数
参考代码如下：

```
int GetLeafNodeNum(BinaryTreeNode * pRoot)
{
	if(pRoot == NULL)
		return 0;
	if(pRoot->m_pLeft == NULL && pRoot->m_pRight == NULL)
		return 1;
	int numLeft = GetLeafNodeNum(pRoot->m_pLeft); // 左子树中叶节点的个数
	int numRight = GetLeafNodeNum(pRoot->m_pRight); // 右子树中叶节点的个数
	return (numLeft + numRight);
}
```

### 8. 判断两棵二叉树是否结构相同
不考虑数据内容。结构相同意味着对应的左子树和对应的右子树都结构相同。
递归解法：
（1）如果两棵二叉树都为空，返回真
（2）如果两棵二叉树一棵为空，另一棵不为空，返回假
（3）如果两棵二叉树都不为空，如果对应的左子树和右子树都同构返回真，其他返回假
参考代码如下：

```
bool StructureCmp(BinaryTreeNode * pRoot1, BinaryTreeNode * pRoot2)
{
	if(pRoot1 == NULL && pRoot2 == NULL) // 都为空，返回真
		return true;
	else if(pRoot1 == NULL || pRoot2 == NULL) // 有一个为空，一个不为空，返回假
		return false;
	bool resultLeft = StructureCmp(pRoot1->m_pLeft, pRoot2->m_pLeft); // 比较对应左子树 
	bool resultRight = StructureCmp(pRoot1->m_pRight, pRoot2->m_pRight); // 比较对应右子树
	return (resultLeft && resultRight);
} 
```

### 9. 判断二叉树是不是平衡二叉树
递归解法：
（1）如果二叉树为空，返回真
（2）如果二叉树不为空，如果左子树和右子树都是AVL树并且左子树和右子树高度相差不大于1，返回真，其他返回假
参考代码：

```
bool IsAVL(BinaryTreeNode * pRoot, int & height)
{
	if(pRoot == NULL) // 空树，返回真
	{
		height = 0;
		return true;
	}
	int heightLeft;
	bool resultLeft = IsAVL(pRoot->m_pLeft, heightLeft);
	int heightRight;
	bool resultRight = IsAVL(pRoot->m_pRight, heightRight);
	if(resultLeft && resultRight && abs(heightLeft - heightRight) <= 1) // 左子树和右子树都是AVL，并且高度相差不大于1，返回真
	{
		height = max(heightLeft, heightRight) + 1;
		return true;
	}
	else
	{
		height = max(heightLeft, heightRight) + 1;
		return false;
	}
}
```

### 10. 求二叉树的镜像
递归解法：
（1）如果二叉树为空，返回空
（2）如果二叉树不为空，求左子树和右子树的镜像，然后交换左子树和右子树
参考代码如下：

```
BinaryTreeNode * Mirror(BinaryTreeNode * pRoot)
{
	if(pRoot == NULL) // 返回NULL
		return NULL;
	BinaryTreeNode * pLeft = Mirror(pRoot->m_pLeft); // 求左子树镜像
	BinaryTreeNode * pRight = Mirror(pRoot->m_pRight); // 求右子树镜像
        // 交换左子树和右子树
	pRoot->m_pLeft = pRight;
	pRoot->m_pRight = pLeft;
	return pRoot;
}
```

### 11. 求二叉树中两个节点的最低公共祖先节点
递归解法：
（1）如果两个节点分别在根节点的左子树和右子树，则返回根节点
（2）如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树
参考代码如下：

```
bool FindNode(BinaryTreeNode * pRoot, BinaryTreeNode * pNode)
{
	if(pRoot == NULL || pNode == NULL)
		return false;

	if(pRoot == pNode)
		return true;

	bool found = FindNode(pRoot->m_pLeft, pNode);
	if(!found)
		found = FindNode(pRoot->m_pRight, pNode);

	return found;
}

BinaryTreeNode * GetLastCommonParent(BinaryTreeNode * pRoot, 
                                     BinaryTreeNode * pNode1, 
                                     BinaryTreeNode * pNode2)
{
	if(FindNode(pRoot->m_pLeft, pNode1))
	{
		if(FindNode(pRoot->m_pRight, pNode2))
			return pRoot;
		else
			return GetLastCommonParent(pRoot->m_pLeft, pNode1, pNode2);
	}
	else
	{
		if(FindNode(pRoot->m_pLeft, pNode2))
			return pRoot;
		else
			return GetLastCommonParent(pRoot->m_pRight, pNode1, pNode2);
	}
}
```

递归解法效率很低，有很多重复的遍历，下面看一下非递归解法。
非递归解法：
先求从根节点到两个节点的路径，然后再比较对应路径的节点就行，最后一个相同的节点也就是他们在二叉树中的最低公共祖先节点
参考代码如下：

```
bool GetNodePath(BinaryTreeNode * pRoot, BinaryTreeNode * pNode, 
                 list<BinaryTreeNode *> & path)
{
	if(pRoot == pNode)
	{	
		path.push_back(pRoot);
		return true;
	}
	if(pRoot == NULL)
		return false;
	path.push_back(pRoot);
	bool found = false;
	found = GetNodePath(pRoot->m_pLeft, pNode, path);
	if(!found)
		found = GetNodePath(pRoot->m_pRight, pNode, path);
	if(!found)
		path.pop_back();
	return found;
}

BinaryTreeNode * GetLastCommonParent(BinaryTreeNode * pRoot, BinaryTreeNode * pNode1, BinaryTreeNode * pNode2)
{
	if(pRoot == NULL || pNode1 == NULL || pNode2 == NULL)
		return NULL;
	list<BinaryTreeNode*> path1;
	bool bResult1 = GetNodePath(pRoot, pNode1, path1);
	list<BinaryTreeNode*> path2;
	bool bResult2 = GetNodePath(pRoot, pNode2, path2);
	if(!bResult1 || !bResult2) 
		return NULL;
	BinaryTreeNode * pLast = NULL;
	list<BinaryTreeNode*>::const_iterator iter1 = path1.begin();
	list<BinaryTreeNode*>::const_iterator iter2 = path2.begin();
	while(iter1 != path1.end() && iter2 != path2.end())
	{
		if(*iter1 == *iter2)
			pLast = *iter1;
		else
			break;
		iter1++;
		iter2++;
	}
	return pLast;
}
```

在上述算法的基础上稍加变化即可求二叉树中任意两个节点的距离了。

### 12. 求二叉树中节点的最大距离
即二叉树中相距最远的两个节点之间的距离。
递归解法：
1、如果二叉树为空，返回0，同时记录左子树和右子树的深度，都为0
2、如果二叉树不为空，最大距离要么是左子树中的最大距离，要么是右子树中的最大距离，要么是左子树节点中到根节点的最大距离+右子树节点中到根节点的最大距离，同时记录左子树和右子树节点中到根节点的最大距离。
参考代码如下：

```
int GetMaxDistance(BinaryTreeNode * pRoot, int & maxLeft, int & maxRight)
{
	// maxLeft, 左子树中的节点距离根节点的最远距离
	// maxRight, 右子树中的节点距离根节点的最远距离
	if(pRoot == NULL)
	{
		maxLeft = 0;
		maxRight = 0;
		return 0;
	}
	int maxLL, maxLR, maxRL, maxRR;
	int maxDistLeft, maxDistRight;
	if(pRoot->m_pLeft != NULL)
	{
		maxDistLeft = GetMaxDistance(pRoot->m_pLeft, maxLL, maxLR);
		maxLeft = max(maxLL, maxLR) + 1;
	}
	else
	{
		maxDistLeft = 0;
		maxLeft = 0;
	}
	if(pRoot->m_pRight != NULL)
	{
		maxDistRight = GetMaxDistance(pRoot->m_pRight, maxRL, maxRR);
		maxRight = max(maxRL, maxRR) + 1;
	}
	else
	{
		maxDistRight = 0;
		maxRight = 0;
	}
	return max(max(maxDistLeft, maxDistRight), maxLeft+maxRight);
}
```

### 13. 由前序遍历序列和中序遍历序列重建二叉树
二叉树前序遍历序列中，第一个元素总是树的根节点的值。中序遍历序列中，左子树的节点的值位于根节点的值的左边，右子树的节点的值位于根节点的值的右边。
递归解法：
1、如果前序遍历为空或中序遍历为空或节点个数小于等于0，返回NULL。
2、创建根节点。前序遍历的第一个数据就是根节点的数据，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树。

```
BinaryTreeNode * RebuildBinaryTree(int* pPreOrder, int* pInOrder, int nodeNum)
{
	if(pPreOrder == NULL || pInOrder == NULL || nodeNum <= 0)
		return NULL;
	BinaryTreeNode * pRoot = new BinaryTreeNode;
	// 前序遍历的第一个数据就是根节点数据
	pRoot->m_nValue = pPreOrder[0];
	pRoot->m_pLeft = NULL;
	pRoot->m_pRight = NULL;
	// 查找根节点在中序遍历中的位置，中序遍历中，根节点左边为左子树，右边为右子树
	int rootPositionInOrder = -1;
	for(int i = 0; i < nodeNum; i++)
		if(pInOrder[i] == pRoot->m_nValue)
		{
			rootPositionInOrder = i;
			break;
		}
	if(rootPositionInOrder == -1)
	{
		throw std::exception("Invalid input.");
	}
	// 重建左子树
	int nodeNumLeft = rootPositionInOrder;
	int * pPreOrderLeft = pPreOrder + 1;
	int * pInOrderLeft = pInOrder;
	pRoot->m_pLeft = RebuildBinaryTree(pPreOrderLeft, pInOrderLeft, nodeNumLeft);
	// 重建右子树
	int nodeNumRight = nodeNum - nodeNumLeft - 1;
	int * pPreOrderRight = pPreOrder + 1 + nodeNumLeft;
	int * pInOrderRight = pInOrder + nodeNumLeft + 1;
	pRoot->m_pRight = RebuildBinaryTree(pPreOrderRight, pInOrderRight, nodeNumRight);
	return pRoot;
}
```

同样，有中序遍历序列和后序遍历序列，类似的方法可重建二叉树，但前序遍历序列和后序遍历序列不同恢复一棵二叉树，证明略。

### 14.判断二叉树是不是完全二叉树
若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。
有如下算法，按层次（从上到下，从左到右）遍历二叉树，当遇到一个节点的左子树为空时，则该节点右子树必须为空，且后面遍历的节点左右子树都必须为空，否则不是完全二叉树。

```
bool IsCompleteBinaryTree(BinaryTreeNode * pRoot)
{
	if(pRoot == NULL)
		return false;
	queue<BinaryTreeNode *> q;
	q.push(pRoot);
	bool mustHaveNoChild = false;
	bool result = true;
	while(!q.empty())
	{
		BinaryTreeNode * pNode = q.front();
		q.pop();
		if(mustHaveNoChild) // 已经出现了有空子树的节点了，后面出现的必须为叶节点（左右子树都为空）
		{
			if(pNode->m_pLeft != NULL || pNode->m_pRight != NULL)
			{
				result = false;
				break;
			}
		}
		else
		{
			if(pNode->m_pLeft != NULL && pNode->m_pRight != NULL)
			{
				q.push(pNode->m_pLeft);
				q.push(pNode->m_pRight);
			}
			else if(pNode->m_pLeft != NULL && pNode->m_pRight == NULL)
			{
				mustHaveNoChild = true;
				q.push(pNode->m_pLeft);
			}
			else if(pNode->m_pLeft == NULL && pNode->m_pRight != NULL)
			{
				result = false;
				break;
			}
			else
			{
				mustHaveNoChild = true;
			}
		}
	}
	return result;
}
```

## 算法面试题

### 1、将一整数逆序后放入一数组中（要求递归实现）

```
void convert(int *result, int n) {
	if(n>=10)
		convert(result+1, n/10);
	*result = n%10;	
}

int main(int argc, char* argv[]) {
	int n = 123456789, result[20]={};
	convert(result, n);
	printf("%d:", n);
	for(int i=0; i<9; i++)
		printf("%d", result[i]);
}
```

### 2、求高于平均分的学生学号及成绩（学号和成绩人工输入）

```
double find(int total, int n) {
	int number, score,  average;
	scanf("%d", &number);
	if(number != 0) {
		scanf("%d", &score);
		average = find(total+score, n+1);
		if(score >= average)
			printf("%d:%d\n", number, score);
		return average;
	} else {
		printf("Average=%d\n", total/n);
		return total/n;
	}
}

int main(int argc, char* argv[]) {
	find(0, 0);
}
```

### 3、递归实现回文判断（如：abcdedbca就是回文，判断一个面试者对递归理解的简单程序）

```
int find(char *str, int length) {
   //根据字符串的长度进行判断：
	if(length<=1)	
	   return 1; //1、长度小于等于1，是回文数
	else if(str[0]==str[length-1])
	   return find(str+1, length-2); //2、前后相等，继续判断，指针前移，长度减2
	else		
	   return 0;
}

int main(int argc, char* argv[]) {
	char *str = "abcdedcba";
	printf("%s: %s\n", str, find(str, strlen(str)) ? "Yes" : "No");
}
```

### 4、组合问题（从M个不同字符中任取N个字符的所有组合）

```
void find(char *source, char *result, int n) {
	if(n==1) {
	   //一个字符串中，取一个字符，直接遍历取出就好
		while(*source)
		   printf("%s%c\n", result, *source++);
	} else {
		int i, j;
		for(i=0; source[i] != 0; i++);
		for(j=0; result[j] != 0; j++);
		for(; i>=n; i--) {
			result[j] = *source++;
			result[j+1] = '\0';
			find(source, result, n-1);
		}
	}
}

int main(int argc, char* argv[]) {
	int const n = 3;
	char *source = "ABCDE", result[n+1] = {0};
	if(n>0 && strlen(source)>0 && n<=strlen(source))
		find(source, result, 3);
}

```

### 5、分解成质因数(如435234=251*17*17*3*2，据说是华为笔试题)

```
void prim(int m, int n) {
	if(m>n) {
		while(m%n != 0) 
		 n++;
		
		m /= n;
		prim(m, n);
		printf("%d*", n);
	}
}
int main(int argc, char* argv[]) {
	int n = 435234;
	printf("%d=", n);
	prim(n, 2);
}
```

### 6、寻找迷宫的一条出路，o：通路； X：障碍。（大家经常谈到的一个小算法题）


```
#define MAX_SIZE  8
int H[4] = {0, 1, 0, -1}; 
int V[4] = {-1, 0, 1, 0};           
char Maze[MAX_SIZE][MAX_SIZE] = {{'X','X','X','X','X','X','X','X'},
                                 {'o','o','o','o','o','X','X','X'},
                                 {'X','o','X','X','o','o','o','X'},
                           		{'X','o','X','X','o','X','X','o'},
                      			{'X','o','X','X','X','X','X','X'},
{'X','o','X','X','o','o','o','X'},
  							{'X','o','o','o','o','X','o','o'},
                                 {'X','X','X','X','X','X','X','X'}};
void FindPath(int X, int Y) {
    if(X == MAX_SIZE || Y == MAX_SIZE) {
      	for(int i = 0; i < MAX_SIZE; i++)
for(int j = 0; j < MAX_SIZE; j++)
                  printf("%c%c", Maze[i][j], j < MAX_SIZE-1 ? ' ' : '\n');
}else for(int k = 0; k < 4; k++) 
if(X >= 0 && Y >= 0 && Y < MAX_SIZE && X < MAX_SIZE && 'o' == Maze[X][Y]) {
                  	Maze[X][Y] = ' ';
                  	FindPath(X+V[k], Y+H[k]);
                  	Maze[X][Y] ='o'; 
}
}
int main(int argc, char* argv[]) {
    FindPath(1,0);
}
```

### 7、随机分配座位，共50个学生，使学号相邻的同学座位不能相邻(早些时候用C#写的，没有用C改写）。

```
static void Main(string[] args)
{
	int Tmp = 0, Count = 50;			
	int[] Seats = new int[Count];			
	bool[] Students = new bool[Count];
	System.Random RandStudent=new System.Random();
	Students[Seats[0]=RandStudent.Next(0,Count)]=true;
	for(int i = 1; i < Count; ) {
	    Tmp=(int)RandStudent.Next(0,Count);
	    if((!Students[Tmp])&&(Seats[i-1]-Tmp!=1) && (Seats[i-1] - Tmp) != -1) {
			Seats[i++] = Tmp;
Students[Tmp] = true;
		}
	}
	foreach(int Student in Seats)
	    System.Console.Write(Student + " ");
	System.Console.Read();
}
```

### 8、求网格中的黑点分布。现有6*7的网格，在某些格子中有黑点，已知各行与各列中有黑点的点数之和，请在这张网格中画出黑点的位置。（这是一网友提出的题目，说是他笔试时遇到算法题）

```
#define ROWS 6
#define COLS 7
int iPointsR[ROWS] = {2, 0, 4, 3, 4, 0};           // 各行黑点数和的情况
int iPointsC[COLS] = {4, 1, 2, 2, 1, 2, 1};        // 各列黑点数和的情况
int iCount, iFound;
int iSumR[ROWS], iSumC[COLS], Grid[ROWS][COLS];

int Set(int iRowNo) {
    if(iRowNo == ROWS) { 
            for(int iColNo=0; iColNo < COLS && iSumC[iColNo]==iPointsC[iColNo]; iColNo++) 
               if(iColNo == COLS-1) {
                   printf("\nNo.%d:\n", ++iCount); 
                   for(int i=0; i < ROWS; i++)
                      for(int j=0; j < COLS; j++)
                          printf("%d%c", Grid[i][j], (j+1) % COLS ? ' ' : '\n');
                   iFound = 1;	// iFound = 1，有解
               }
        } else {
            for(int iColNo=0; iColNo < COLS; iColNo++) {
                if(iPointsR[iRowNo] == 0) { 
                    Set(iRowNo + 1);
       } else if(Grid[iRowNo][iColNo]==0) { 
    Grid[iRowNo][iColNo] = 1; 
    iSumR[iRowNo]++; iSumC[iColNo]++;                                  if(iSumR[iRowNo]<iPointsR[iRowNo] && iSumC[iColNo]<=iPointsC[iColNo])
                         Set(iRowNo);
    else if(iSumR[iRowNo]==iPointsR[iRowNo] && iRowNo < ROWS)
                         Set(iRowNo + 1);
                    Grid[iRowNo][iColNo] = 0;
                    iSumR[iRowNo]--; 
    iSumC[iColNo]--;
                }
            }
        }
    return iFound;   		// 用于判断是否有解
}
int main(int argc, char* argv[]) {
    if(!Set(0))
        printf("Failure!"); 
}
```

### 9、有4种面值的邮票很多枚，这4种邮票面值分别1, 4, 12, 21，现从多张中最多任取5张进行组合，求取出这些邮票的最大连续组合值。（据说是华为2003年校园招聘笔试题）

```
#define N 5
#define M 5
int k, Found, Flag[N];
int Stamp[M] = {0, 1, 4, 12, 21};

//在剩余张数n中组合出面值和Value
int Combine(int n, int Value) {
	if(n >= 0 && Value == 0) {
		Found = 1;
		int Sum = 0;
		for(int i=0; i<N && Flag[i] != 0; i++) {
			Sum += Stamp[Flag[i]];
			printf("%d ", Stamp[Flag[i]]);
		}
		printf("\tSum=%d\n\n", Sum);
	}else for(int i=1; i<M && !Found && n>0; i++)
		if(Value-Stamp[i] >= 0) {
			Flag[k++] = i;
			Combine(n-1, Value-Stamp[i]);
			Flag[--k] = 0;
		}
	return Found;
}

int main(int argc, char* argv[]) {
	for(int i=1; Combine(N, i); i++, Found=0);
}
```

### 10、大整数数相乘的问题。（这是2002年在一考研班上遇到的算法题）

```
void Multiple(char A[], char B[], char C[]) {
    int TMP, In=0, LenA=-1, LenB=-1;
    while(A[++LenA] != '\0');
    while(B[++LenB] != '\0');
    int Index, Start = LenA + LenB - 1;
    for(int i=LenB-1; i>=0; i--) {
        Index = Start--;
        if(B[i] != '0') {
            for(int In=0, j=LenA-1; j>=0; j--) {
                TMP = (C[Index]-'0') + (A[j]-'0') * (B[i] - '0') + In;
                C[Index--] = TMP % 10 + '0';
                In = TMP / 10;
            }
            C[Index] = In + '0';
        }
    }
}

int main(int argc, char* argv[]) {
    char A[] = "21839244444444448880088888889";
    char B[] = "38888888888899999999999999988";
    char C[sizeof(A) + sizeof(B) - 1];

    for(int k=0; k<sizeof(C); k++)
        C[k] = '0';
    C[sizeof(C)-1] = '\0';

    Multiple(A, B, C);
    for(int i=0; C[i] != '\0'; i++)
        printf("%c", C[i]);
}
```

### 11、求最大连续递增数字串（如“ads3sl456789DF3456ld345AA”中的“456789”）

```
int GetSubString(char *strSource, char *strResult) {
    int iTmp=0, iHead=0, iMax=0;
    for(int Index=0, iLen=0; strSource[Index]; Index++) {
        if(strSource[Index] >= '0' && strSource[Index] <= '9' && 
strSource[Index-1] > '0' && strSource[Index] == strSource[Index-1]+1) {
            iLen++;                       // 连续数字的长度增1 
        } else {                          // 出现字符或不连续数字
            if(iLen > iMax) {
            iMax = iLen; 	iHead = iTmp; 
            }        
   		   // 该字符是数字，但数字不连续
            if(strSource[Index] >= '0' && strSource[Index] <= '9') { 
                iTmp = Index; 
                iLen = 1; 
            }
        }    
    }
    for(iTmp=0 ; iTmp < iMax; iTmp++)	// 将原字符串中最长的连续数字串赋值给结果串
        strResult[iTmp] = strSource[iHead++];
    strResult[iTmp]='\0';
    return iMax;					// 返回连续数字的最大长度
}
int main(int argc, char* argv[]) {
    char strSource[]="ads3sl456789DF3456ld345AA", char strResult[sizeof(strSource)];
printf("Len=%d, strResult=%s \nstrSource=%s\n", 
GetSubString(strSource, strResult), strResult, strSource);
}
```

### 12、四个工人，四个任务，每个人做不同的任务需要的时间不同，求任务分配的最优方案。（2005年5月29日全国计算机软件资格水平考试——软件设计师的算法题）。

```
#include "stdafx.h"
#define N 4
int	Cost[N][N] = { {2, 12, 5, 32},		// 行号：任务序号，列号：工人序号
                    {8, 15, 7, 11},		// 每行元素值表示这个任务由不同工人完成所需要的时间
                    {24, 18, 9, 6},
                    {21, 1, 8, 28}};
int MinCost=1000;
int Task[N], TempTask[N], Worker[N];
void Assign(int k, int cost) {
	if(k == N) {
		MinCost = cost;	
		for(int i=0; i<N; i++)
			TempTask[i] = Task[i];
	} else {
		for(int i=0; i<N; i++) {	
			if(Worker[i]==0 && cost+Cost[k][i] < MinCost) {	// 为提高效率而进行剪枝
				Worker[i] = 1;	Task[k] = i; 
				Assign(k+1, cost+Cost[k][i]); 
				Worker[i] = 0; Task[k] = 0;
			}
		}
	}
}
int main(int argc, char* argv[]) {
	Assign(0, 0);
	printf("最佳方案总费用=%d\n", MinCost);
	for(int i=0; i<N; i++)		/* 输出最佳方案 */
		printf("\t任务%d由工人%d来做：%d\n", i, TempTask[i], Cost[i][TempTask[i]]);
}
```

### 13、八皇后问题，输出了所有情况，不过有些结果只是旋转了90度而已。（回溯算法的典型例题，是数据结构书上算法的具体实现，大家都亲自动手写过这个程序吗？）

```
#define N 8
int Board[N][N];
int Valid(int i, int j) {		// 判断下棋位置是否有效
	int k = 1;
	for(k=1; i>=k && j>=k;k++)
		if(Board[i-k][j-k])	return 0;
	for(k=1; i>=k;k++)
		if(Board[i-k][j])		return 0;
	for(k=1; i>=k && j+k<N;k++)
		if(Board[i-k][j+k])	return 0;
	return 1;
}

void Trial(int i, int n) {		// 寻找合适下棋位置
	if(i == n) {
		for(int k=0; k<n; k++) {
			for(int m=0; m<n; m++)
				printf("%d ", Board[k][m]);
			printf("\n");
		}
		printf("\n");
	} else {
		for(int j=0; j<n; j++) {
			Board[i][j] = 1;
			if(Valid(i,j))
				Trial(i+1, n);
			Board[i][j] = 0;
		}
	}
}

int main(int argc, char* argv[]) {
	Trial(0, N);
}
```

### 14、实现strstr功能，即在父串中寻找子串首次出现的位置。（笔试中常让面试者实现标准库中的一些函数）

```
char * strstring(char *ParentString, char *SubString) {
	char *pSubString, *pPareString;
	for(char *pTmp=ParentString; *pTmp; pTmp++) {
		pSubString = SubString;
		pPareString = pTmp;	
		while(*pSubString == *pPareString && *pSubString != '\0') {
			pSubString++;
			pPareString++;
		}
		if(*pSubString == '\0') 	return pTmp;
	}
	return NULL;
}

int main(int argc, char* argv[]) {
	char *ParentString = "happy birthday to you!";
	char *SubString = "birthday";
	printf("%s",strstring(ParentString, SubString));
}
```

### 15、现在小明一家过一座桥，过桥的时候是黑夜，所以必须有灯。现在小明过桥要1分，小明的弟弟要3分，小明的爸爸要6分，小明的妈妈要8分，小明的爷爷要12分。每次此桥最多可过两人，而过桥的速度依过桥最慢者而定，而且灯在点燃后30分就会熄灭。问小明一家如何过桥时间最短？（原本是个小小智力题，据说是外企的面试题，在这里用程序来求解）

```
#include "stdafx.h"
#define N    5
#define SIZE 64

// 将人员编号：小明-0，弟弟-1，爸爸-2，妈妈-3，爷爷-4
// 每个人的当前位置：0--在桥左边， 1--在桥右边
int Position[N];    
// 过桥临时方案的数组下标； 临时方案； 最小时间方案； 
int Index, TmpScheme[SIZE], Scheme[SIZE];   
// 最小过桥时间总和，初始值100；每个人过桥所需要的时间
int MinTime=100, Time[N]={1, 3, 6, 8, 12};  
// 寻找最佳过桥方案。Remnant:未过桥人数; CurTime:当前已用时间; 
// Direction:过桥方向,1--向右,0--向左
void Find(int Remnant, int CurTime, int Direction) {
    if(Remnant == 0) {                               // 所有人已经过桥，更新最少时间及方案
        MinTime=CurTime;
        for(int i=0; i<SIZE && TmpScheme[i]>=0; i++)
            Scheme[i] = TmpScheme[i];
    } else if(Direction == 1) {                        // 过桥方向向右，从桥左侧选出两人过桥
        for(int i=0; i<N; i++)                    
            if(Position[i] == 0 && CurTime + Time[i] < MinTime) { 
                TmpScheme[Index++] = i;
                Position[i] = 1;
                for(int j=0; j<N; j++) {
                    int TmpMax = (Time[i] > Time[j] ? Time[i] : Time[j]);
                    if(Position[j] == 0 && CurTime + TmpMax < MinTime) {
                        TmpScheme[Index++] = j;    
                        Position[j] = 1;        
                        Find(Remnant - 2, CurTime + TmpMax, !Direction); 
                        Position[j] = 0;        
                        TmpScheme[--Index] = -1;
                    }
                }
                Position[i] = 0;
                TmpScheme[--Index] = -1;
            }
    } else {        // 过桥方向向左，从桥右侧选出一个人回来送灯
        for(int j=0; j<N; j++) {
            if(Position[j] == 1 && CurTime+Time[j] < MinTime) {
                TmpScheme[Index++] = j;
                Position[j] = 0;
                Find(Remnant+1, CurTime+Time[j], !Direction);
                Position[j] = 1;
                TmpScheme[--Index] = -1;
            }
        }
    }
}
int main(int argc, char* argv[]) {
    for(int i=0; i<SIZE; i++) 		// 初始方案内容为负值，避免和人员标号冲突
        Scheme[i] = TmpScheme[i] = -1;

Find(N, 0, 1);    				// 查找最佳方案

    printf("MinTime=%d:", MinTime);	// 输出最佳方案
    for(int i=0; i<SIZE && Scheme[i]>=0; i+=3)
        printf("  %d-%d  %d", Scheme[i], Scheme[i+1], Scheme[i+2]);
    printf("\b\b  ");
}
```

### 16、2005年11月金山笔试题。编码完成下面的处理函数。函数将字符串中的字符'*'移到串的前部分，前面的非'*'字符后移，但不能改变非'*'字符的先后顺序，函数返回串中字符'*'的数量。如原始串为：ab**cd**e*12，处理后为*****abcde12，函数并返回值为5。（要求使用尽量少的时间和辅助空间）

```
int change(char *str) {					/* 这个算法并不高效，从后向前搜索效率要高些 */
	int count = 0;					/* 记录串中字符'*'的个数 */
	for(int i=0, j=0; str[i]; i++) {		/* 重串首开始遍历 */
		if(str[i]=='*') {				/* 遇到字符'*' */
			for(j=i-1; str[j]!='*'&&j>=0; j--) /* 采用类似插入排序的思想，将*前面 */
				str[j+1]=str[j];			  /* 的非*字符逐个后移，直到遇到*字符 */
			str[j+1] = '*';
			count++;
		}
	}
	return count;
}
int main(int argc, char* argv[]) {
	char str[] = "ab**cd**e*12";
	printf("str1=%s\n", str);
	printf("str2=%s, count=%d", str, change(str));
}
// 终于得到一个比较高效的算法，一个网友提供，估计应该和金山面试官的想法一致。算法如下：
int change(char *str) {
	int i,j=strlen(str)-1;
	for(i=j; j>=0; j--) {
		if(str[i]!='*') {
			i--;
		} else if(str[j]!='*') {
			str[i] = str[j];
			str[j] = '*';
			i--;
		}
	}
	return i+1;
}
```

### 17、2005年11月15日华为软件研发笔试题。实现一单链表的逆转。

```
#include "stdafx.h"
typedef char eleType;		// 定义链表中的数据类型
typedef struct listnode	 {	// 定义单链表结构
	eleType data;
	struct listnode *next;
}node;

node *create(int n) {		// 创建单链表，n为节点个数
	node *p = (node *)malloc(sizeof(node));	
	node *head = p; 	head->data = 'A';
	for(int i='B'; i<'A'+n; i++) {				
		p = (p->next = (node *)malloc(sizeof(node)));
		p->data = i;
		p->next = NULL;		
	}
	return head;
}

void print(node *head)	{	// 按链表顺序输出链表中元素
	for(; head; head = head->next)
		printf("%c ", head->data);	
	printf("\n");
}

node *reverse(node *head, node *pre) {	// 逆转单链表函数。这是笔试时需要写的最主要函数
	node *p=head->next;
	head->next = pre;
	if(p)	return reverse(p, head);
	else		return head;
}

int main(int argc, char* argv[]) {
	node *head = create(6);
	print(head);
	head = reverse(head, NULL);
	print(head);
}
```

### 18、编码实现字符串转整型的函数（实现函数atoi的功能），据说是神州数码笔试题。如将字符串 ”+123”123, ”-0123”-123, “123CS45”123, “123.45CS”123, “CS123.45”0

```
#include "stdafx.h"
int str2int(const char *str) {				// 字符串转整型函数
	int i=0, sign=1, value = 0;
	if(str==NULL)	 return NULL;				// 空串直接返回 NULL
	if(str[0]=='-' || str[0]=='+') {			// 判断是否存在符号位
		i = 1;
		sign = (str[0]=='-' ? -1 : 1);
	}
	for(; str[i]>='0' && str[i]<='9'; i++)	// 如果是数字，则继续转换
		value = value * 10 + (str[i] - '0');
	return sign * value;
}

int main(int argc, char *argv[]) {
	char *str = "-123.45CS67"; 
	int  val  = str2int(str);
	printf("str=%s\tval=%d\n", str, val);
}
```

### 19、歌德巴赫猜想。任何一个偶数都可以分解为两个素数之和。（其实这是个C二级考试的模拟试题）

```
#include "stdafx.h"
#include "math.h"
int main(int argc, char* argv[]) {
	int Even=78, Prime1, Prime2, Tmp1, Tmp2;
	for(Prime1=3; Prime1<=Even/2; Prime1+=2) {
		for(Tmp1=2,Tmp2=sqrt(float(Prime1)); Tmp1<=Tmp2 && Prime1%Tmp1 != 0; Tmp1++);
		if(Tmp1<=Tmp2) continue;
		Prime2 = Even-Prime1;
		for(Tmp1=2,Tmp2=sqrt(float(Prime2)); Tmp1<=Tmp2 && Prime2%Tmp1 != 0; Tmp1++);
		if(Tmp1<=Tmp2) continue;
		printf("%d=%d+%d\n", Even, Prime1, Prime2);
	}
}
```

### 20、快速排序（东软喜欢考类似的算法填空题，又如堆排序的算法等）

```
#include "stdafx.h"
#define N 10
int part(int list[], int low, int high) {		// 一趟排序，返回分割点位置
	int tmp = list[low];
	while(low<high) {
		while(low<high && list[high]>=tmp) --high;
		list[low] = list[high];
		while(low<high && list[low]<=tmp)  ++low;
		list[high] = list[low];
	}
	list[low] = tmp;
	return low;
}
void QSort(int list[], int low, int high)	{	// 应用递归进行快速排序
	if(low<high) {
		int mid = part(list, low, high);
		QSort(list, low, mid-1);
		QSort(list, mid+1, high);
	}
}
void show(int list[], int n) {				// 输出列表中元素
	for(int i=0; i<n; i++)
		printf("%d ", list[i]);
	printf("\n");
}
int main(int argc, char* argv[]) {
	int list[N] = {23, 65, 26, 1, 6, 89, 3, 12, 33, 8};
	show(list, N);						// 输出排序前序列
	QSort(list, 0, N-1);					// 快速排序
	show(list, N);						// 输出排序后序列
}

```

### 21、2005年11月23日慧通笔试题：写一函数判断某个整数是否为回文数，如12321为回文数。可以用判断入栈和出栈是否相同来实现（略微复杂些），这里是将整数逆序后形成另一整数，判断两个整数是否相等来实现的。

```
#include "stdafx.h"
int IsEchoNum(int num) {
	int tmp = 0;
	for(int n = num; n; n/=10)
		tmp = tmp *10 + n%10;
	return tmp==num;
}

int main(int argc, char* argv[]) {
	int num = 12321;
	printf("%d  %d\n", num, IsEchoNum(num));
}
```

### 22、删除字符串中的数字并压缩字符串（神州数码以前笔试题），如字符串”abc123de4fg56”处理后变为”abcdefg”。注意空间和效率。（下面的算法只需要一次遍历，不需要开辟新空间，时间复杂度为O(N)）

```
#include "stdafx.h"
void delNum(char *str) {
	int i, j=0;
   //找到串中第一个数字的位子
	for(i=j=0; str[i] && (str[i]<'0' || str[i]>'9'); j=++i);
	
	// 从串中第一个数字的位置开始，逐个放入后面的非数字字符
	for(; str[i]; i++)			
		if(str[i]<'0' || str[i]>'9') 
			str[j++] = str[i];
	str[j] = '\0';
}

int main(int argc, char* argv[]) {
	char str[] = "abc123ef4g4h5";
	printf("%s\n", str);
	delNum(str);
	printf("%s\n", str);
}

```

### 23、求两个串中的第一个最长子串（神州数码以前试题）。如"abractyeyt","dgdsaeactyey"的最大子串为"actyet"。

```
#include "stdafx.h"
char *MaxSubString(char *str1, char *str2) {
	int i, j, k, index, max=0;
	for(i=0; str1[i]; i++)
		for(j=0; str2[j]; j++) {
			for(k=0; str1[i+k]==str2[j+k] && (str2[i+k] || str1[i+k]); k++);
			if(k>max) {		//出现大于当前子串长度的子串，则替换子串位置和程度
				index = j;	max = k;
			}
		}
	char *strResult = (char *)calloc(sizeof(char), max+1);
	for(i=0; i<max; i++)		
		strResult[i] = str2[index++];
	return strResult;
}

int main(int argc, char* argv[]) {
	char str1[] = "abractyeyt", str2[] = "dgdsaeactyey";
	char *strResult = MaxSubString(str1, str2);
	printf("str1=%s\nstr2=%s\nMaxSubString=%s\n", str1, str2, strResult);
}
```

### 24、不开辟用于交换数据的临时空间，如何完成字符串的逆序 (在技术一轮面试中，有些面试官会这样问)

```
#include "stdafx.h"
void change(char *str) {
	for(int i=0,j=strlen(str)-1; i<j; i++, j--){
		str[i] ^= str[j] ^= str[i] ^= str[j];
	}
}

int main(int argc, char* argv[]) {
	char str[] = "abcdefg";
	printf("strSource=%s\n", str);
	change(str);
	printf("strResult=%s\n", str);
	return getchar();
}
```

### 25、删除串中指定的字符（做此题时，千万不要开辟新空间，否则面试官可能认为你不适合做嵌入式开发）

```
#include "stdafx.h"
void delChar(char *str, char c) {
	int i, j=0;
	for(i=0; str[i]; i++) {
	   if(str[i] != c) {
	       str[j++]=str[i];
	   }
	}
	str[j] = '\0';
}

int main(int argc, char* argv[]) {
	char str[] = "abcdefgh";	// 注意，此处不能写成char *str = "abcdefgh";
	printf("%s\n", str);
	delChar(str, 'c');
	printf("%s\n", str);
}
```

### 26、判断单链表中是否存在环（网上说的笔试题）

```
#include "stdafx.h"
typedef char eleType;				// 定义链表中的数据类型
typedef struct listnode	 {			// 定义单链表结构
	eleType data;
	struct listnode *next;
}node;

node *create(int n) {				// 创建单链表，n为节点个数
	node *p = (node *)malloc(sizeof(node));	
	node *head = p; 	head->data = 'A';
	for(int i='B'; i<'A'+n; i++) {
		p = (p->next = (node *)malloc(sizeof(node)));
		p->data = i;
		p->next = NULL;
	}
	return head;
}

void addCircle(node *head, int n) {	// 增加环，将链尾指向链中第n个节点
	node *q, *p = head;
	for(int i=1; p->next; i++) {
		if(i==n) q = p;
		p = p->next;
	}
	p->next = q;
}

int isCircle(node *head) {			// 这是笔试时需要写的最主要函数，其他函数可以不写
	node *p=head,*q=head; 
	while( p->next && q->next) { 
		p = p->next;
		if (NULL == (q=q->next->next))	return 0;
		if (p == q)	return 1;
	}
	return 0; 
}

int main(int argc, char* argv[]) {
	node *head = create(12);
	addCircle(head, 8);			// 注释掉此行，连表就没有环了
	printf("%d\n", isCircle(head));
}
```

