# 大公司面试汇总-多线程

* [大公司面试汇总-多线程](#大公司面试汇总-多线程)
   * [进程和线程的区别【腾讯、百度、阿里】](#进程和线程的区别腾讯百度阿里)
   * [进程和线程的调度方式，临界区，进程同步【阿里】](#进程和线程的调度方式临界区进程同步阿里)
      * [操作系统中的几种常见进程调度算法：](#操作系统中的几种常见进程调度算法)
      * [四种进程或线程<strong>同步互斥</strong>的控制方法](#四种进程或线程同步互斥的控制方法)
   * [线程同步的方式【腾讯】](#线程同步的方式腾讯)
   * [进程间通信的方式【腾讯、百度、美团】](#进程间通信的方式腾讯百度美团)
   * [线程间通信的方式【腾讯、百度、美团】](#线程间通信的方式腾讯百度美团)
   * [多线程，多线程的方式三种方式和它们的区别【头条、百度、网易】](#多线程多线程的方式三种方式和它们的区别头条百度网易)
   * [GCD：假设有8个异步线程，如何先并发三个，再执行一个](#gcd假设有8个异步线程如何先并发三个再执行一个)
   * [GCD：假设有8个异步线程，如何先并发三个，再执行一个，再并发后面4个。【阿里】](#gcd假设有8个异步线程如何先并发三个再执行一个再并发后面4个阿里)
   * [相互依赖的线程如何实现](#相互依赖的线程如何实现)
   * [GCD同步与异步【头条】](#gcd同步与异步头条)
   * [GCD的使用场景【头条】](#gcd的使用场景头条)
* [并发和并行](#并发和并行)
   * [各种队列【百度】](#各种队列百度)
   * [队列和线程的关系【头条】](#队列和线程的关系头条)
   * [一个进程有哪些区【百度】](#一个进程有哪些区百度)
   * [主线程是相对于什么而言的【阿里】](#主线程是相对于什么而言的阿里)
   * [程序在运行时操作系统除了分配内存空间还有什么【腾讯】](#程序在运行时操作系统除了分配内存空间还有什么腾讯)
   * [微信分享大图如何实现，从进程的角度【美团】](#微信分享大图如何实现从进程的角度美团)
   * [进程调度：内核态和用户态的区别【百度】](#进程调度内核态和用户态的区别百度)
   * [两个进程分别指向同一个地址空间并初始化一个值，分别输出是什么【美团】](#两个进程分别指向同一个地址空间并初始化一个值分别输出是什么美团)
   * [iOS中有哪些锁，线程锁，有哪些锁【头条】](#ios中有哪些锁线程锁有哪些锁头条)
   * [产生死锁的原因主要是：](#产生死锁的原因主要是)
   * [线程死锁的四个条件【阿里】](#线程死锁的四个条件阿里)
   * [自旋锁和互斥锁的区别【头条】](#自旋锁和互斥锁的区别头条)
   * [死锁，解决方案。【网易】](#死锁解决方案网易)

### 进程和线程的区别【腾讯、百度、阿里】

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

1) 简而言之，一个程序至少有一个进程，一个进程至少有一个线程。
2) 线程的划分尺度小于进程，使得多线程程序的并发性高。
3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。

### 进程和线程的调度方式，临界区，进程同步【阿里】

进程调度方式：

* 1）非抢占方式：一旦把处理机分配给某进程，就让它一直运行下去，直至该进程完成或阻塞时，才把处理机分配给其它进程。
* 2）抢占方式：允许调度程序根据某种原则，将已分配给该进程的处理机，重新分配给另一进程。
* **最短剩余时间调度算法**（SRT）：它总是选择预期剩余时间最短的进程。只要新进程就绪，且有更短的剩余时间，调度程序就可能抢占当前正在运行的进程。
* **时间片轮转调度算法** (Round Robin, RR)：系统将所有就绪进程按FCFS的原则，排成一个队列依次调度，把 CPU 分配给队首进程，并令其执行一个时间片，通常为 10-100ms。时间片用完后，系统的计时器发出时钟中断，该进程将被剥夺 CPU并插入就绪队列末尾。
* **优先级调度算法**一旦把处理机分配给就绪队列中优先级最高的进程后，该进程便一直执行下去直至完成，或者因该进程发生某事件而放弃处理机时，系统方可将处理机重新分配给另一优先级最高的进程。 

#### 操作系统中的几种常见进程调度算法：
1. 先来先服务调度算法
2. 短作业优先调度算法
3. 优先级调度算法
4. 高响应比优先调度算法
5. 轮转调度算法
6. 多级反馈队列

#### 四种进程或线程**同步互斥**的控制方法
1、临界区: 通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 
2、互斥量: 为协调共同对一个共享资源的单独访问而设计的。 
3、信号量: 为控制一个具有有限数量用户资源而设计。 
4、事 件: 用来通知线程有一些事件已发生，从而启动后继任务的开始。

**临界区：**
保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么 在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操 作共享资源的目的。 

**互斥量**
互斥量跟临界区很相似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。 

**信号量**
信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源 ，这与操作系统中的PV操作相同。它指出了同时访问共享 资源的线程 最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。

**事件**
事件对象也可以通过通知操作的方式来保持线程的同步。并且可以实现不同进程中的线程同步操作。 

[临界区，互斥量，信号量，事件的区别](https://blog.csdn.net/bao_qibiao/article/details/4516196)

### 线程同步的方式【腾讯】

什么是线程同步？
当使用多个线程来访问同一个数据时，非常容易出现线程安全问题(比如多个线程都在操作同一数据导致数据不一致),所以我们用同步机制来解决这些问题。
线程同步的真实意思，其实是“排队”：几个线程之间要排队，一个一个对共享资源进行操作，而不是同时进行操作。

IOS中保持线程同步的常用技术：

1. @synchronized
2. NSLock
3. NSRecursiveLock (回归锁,递归锁)：它可以允许同一线程多次加锁，而不会造成死锁。
4. dispatch_semaphore
5. NSConditionLock条件锁：因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁
6. pthread_mutex
7. OSSpinLock：自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。

OSSpinLock和dispatch_semaphore的效率远远高于其他。
@synchronized和NSConditionLock效率较差。
鉴于OSSpinLock的不安全，所以我们在开发中如果考虑性能的话，建议使用dispatch_semaphore。
如果不考虑性能，只是图个方便的话，那就使用@synchronized。
使用NSRecursiveLock，可以避免死锁，同时性能也不错，建议代码中使用。

[iOS 保证线程同步方式&性能对比](https://www.jianshu.com/p/4edf98a61483)

### 进程间通信的方式【腾讯、百度、美团】

UNIX进程间通信方式包括：管道、FIFO、信号。
System V进程间通信方式包括：System V消息队列、System V信号灯、System V共享内存
POSIX进程间通信包括：posix消息队列、posix信号灯、posix共享内存。

### 线程间通信的方式【腾讯、百度、美团】

* NSThread
    * 优点：比其他两种轻量级。
    * 缺点：需要自己管理线程的生命周期，线程同步。 线程同步对数据的加锁会有一定的开销。
* NSOperation
* GCD
    * 优点：不需要关心线程管理，数据同步的事情。
    * 两者区别：NSOperationQueue可以方便的管理并发、 NSOperation之间的优先级。GCD主要与block结合使用。代码简洁高效

1. 性能:GCD更接近底层，而NSOperationQueue则更高级抽象，所以GCD在追求性能的底层操作来说，是速度最快的。这取决于使用Instruments进行代码性能分析，如有必要的话
2. 从异步操作之间的事务性，顺序行，依赖关系。GCD需要自己写更多的代码来实现，而NSOperationQueue已经内建了这些支持
3. 如果异步操作的过程需要更多的被交互和UI呈现出来，NSOperationQueue会是一个更好的选择。底层代码中，任务之间不太互相依赖，而需要更高的并发能力，GCD则更有优势

[iOS 线程间通讯](https://www.jianshu.com/p/f9f3952a4a74)

### 多线程，多线程的方式三种方式和它们的区别【头条、百度、网易】

1.NSThread
2.NSOperation
3.GCD

GCD基于C、NSOperation基于GCD的封装。

**NSThread：**
（1）使用NSThread对象建立一个线程非常方便
（2）但是！要使用NSThread管理多个线程非常困难，不推荐使用
（3）技巧！使用[NSThread currentThread]获得任务所在线程，适用于这三种技术
（4）使线程休眠3秒：[NSThread sleepForTimeInterval:0.3f];

**GCD：**—— Grand Central Dispatch：
（1）是基于C语言的底层API
（2）用Block定义任务，使用起来非常灵活便捷
（3）提供了更多的控制能力以及操作队列中所不能使用的底层函数

**NSOperation/NSOperationQueue：**
（1）是使用GCD实现的一套Objective-C的API
（2）是面向对象的线程技术
（3）提供了一些在GCD中不容易实现的特性，如：限制最大并发数量、操作之间的依赖关系

[iOS 多线程详解](https://juejin.im/entry/58aacac08ac247006e625b8c)

### GCD：假设有8个异步线程，如何先并发三个，再执行一个

使用：GCD group

```
dispatch_group_t group = dispatch_group_create();
dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
dispatch_group_async(group, queue, ^{
    NSLog(@"同步任务A");
});
    
dispatch_group_async(group, queue, ^{
    NSLog(@"同步任务B");
});
    
dispatch_group_async(group, queue, ^{
    NSLog(@"同步任务C");
});
    
dispatch_group_notify(group, queue, ^{
    NSLog(@"任务完成执行");
});
```

### GCD：假设有8个异步线程，如何先并发三个，再执行一个，再并发后面4个。【阿里】

使用 dispatch_barrier_async：我们需要自己创建并发队列，然后再执行barrier函数，前面ABC三个任务随机，后面DE随机，但是DE的执行必须是等待ABC任务执行完的。

```
dispatch_queue_t queue = dispatch_queue_create(0, DISPATCH_QUEUE_CONCURRENT);
dispatch_async(queue, ^{
    NSLog(@"任务A");
});
    
dispatch_async(queue, ^{
    NSLog(@"任务B");
});
    
dispatch_async(queue, ^{
    NSLog(@"任务C");
});
    
dispatch_barrier_async(queue, ^{
    NSLog(@"阻塞自定义并发队列");
});
    
dispatch_async(queue, ^{
    NSLog(@"任务D");
});
    
dispatch_async(queue, ^{
    NSLog(@"任务E");
});
```

### 相互依赖的线程如何实现

NSOperation 实现相互依赖的线程执行

```
NSBlockOperation *operatioon1 = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@"任务A");
}];
    
NSBlockOperation *operatioon2 = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@"任务B");
}];
    
NSBlockOperation *operatioon3 = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@"任务C");
}];
    
NSBlockOperation *operatioon4 = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@"任务D");
}];
    
[operatioon4 addDependency:operatioon1];
[operatioon4 addDependency:operatioon2];
[operatioon4 addDependency:operatioon3];
    
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
[queue addOperations:@[operatioon1,operatioon2,operatioon3,operatioon4] waitUntilFinished:YES];
NSLog(@"完成之后的操作");
```


### GCD同步与异步【头条】


### GCD的使用场景【头条】

1. 延时执行
2. 定时器
3. 并发遍历
4. 自定义数据监听
5. 监听进程 Mac开发中
6. 单例的创建

## 并发和并行

**并发**是指一个时间段内，有几个程序都在同一个CPU上运行，但任意一个时刻点上只有一个程序在处理机上运行。
**并行**是指一个时间段内，有几个程序都在几个CPU上运行，任意一个时刻点上，有多个程序在同时运行，并且多道程序之间互不干扰。

### 各种队列【百度】


### 队列和线程的关系【头条】

*  一个程序只有一个主队列, 并且主队列是一个特殊的串行队列
*  并行队列 就是多条线程一起 执行任务没有顺序

### 一个进程有哪些区【百度】

1. 栈区
2. 堆区
3. 全局区
4. 常量区？
5. 代码区？

### 主线程是相对于什么而言的【阿里】

主线程，相对子线程来讲
一个App里面只有一个UI主线程

### 程序在运行时操作系统除了分配内存空间还有什么【腾讯】

加载动态库，静态库
创建主线程，

### 微信分享大图如何实现，从进程的角度【美团】

在异步子线程中进行上传图片，处理图片等耗时操作
等上传完成后，再在主线程中更新UI

### 进程调度：内核态和用户态的区别【百度】

**内核态**：当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。
**用户态**：当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。

### 两个进程分别指向同一个地址空间并初始化一个值，分别输出是什么【美团】


### iOS中有哪些锁，线程锁，有哪些锁【头条】

1. @synchronized
2. NSLock
3. NSRecursiveLock (回归锁,递归锁)：它可以允许同一线程多次加锁，而不会造成死锁。
4. dispatch_semaphore
5. NSConditionLock条件锁：因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁
6. pthread_mutex
7. OSSpinLock：自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。

### 产生死锁的原因主要是：

（1）因为系统资源不足。
（2）进程运行推进的顺序不合适。
（3）资源分配不当等。

### 线程死锁的四个条件【阿里】

互斥条件、不可剥夺条件、请求和保持条件、环等待条件


### 自旋锁和互斥锁的区别【头条】

自旋锁与互斥锁的区别：线程在申请自旋锁的时候，线程不会被挂起，而是处于忙等的状态。

互斥锁的起始原始开销要高于自旋锁，但是基本是一劳永逸，临界区持锁时间的大小并不会对互斥锁的开销造成影响，而自旋锁是死循环检测，加锁全程消耗cpu，起始开销虽然低于互斥锁，但是随着持锁时间，加锁的开销是线性增长。

自旋锁与互斥锁有点类似，只是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是 否该自旋锁的保持者已经释放了锁，"自旋"一词就是因此而得名。

### 死锁，解决方案。【网易】

理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。

此外，也要防止进程在处于等待状态的情况下占用资源,在系统运行过程中，对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否 分配资源，若分配后系统可能发生死锁，则不予分配，否则予以分配 。因此，对资源的分配要给予合理的规划。


