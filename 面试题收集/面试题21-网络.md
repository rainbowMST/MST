# 大公司面试汇总-网络

* [计算机存储单位](#计算机存储单位)
* [HTTP](#http)
   * [概念](#概念)
   * [HTTP的特性](#http的特性)
   * [HTTP 常用状态码：](#http-常用状态码)
   * [Http1.1如1.0的区别](#http11如10的区别)
   * [Http2.0如1.x的区别【百度】](#http20如1x的区别百度)
   * [发送一个HTTP请求的过程【百度】](#发送一个http请求的过程百度)
   * [请简述一下 DNS。【头条】](#请简述一下-dns头条)
   * [有听过 HTTPDNS 吗？【头条】](#有听过-httpdns-吗头条)
   * [HTTP 有哪些部分【美团】](#http-有哪些部分美团)
    * [HTTP请求包含的部分](#http请求包含的部分)
    * [HTTP响应包含的部分](#http响应包含的部分)
   * [HTTP头部有哪些内容【腾讯】](#http头部有哪些内容腾讯)
   * [HTTP 如何保证传输到达，TCP是如何保证可靠的【腾讯】](#http-如何保证传输到达tcp是如何保证可靠的腾讯)
   * [为什么要使用HTTP？为什么不直接用TCP【腾讯】](#为什么要使用http为什么不直接用tcp腾讯)
   * [GET 和 POST 的区别【美团】](#get-和-post-的区别美团)
* [HTTPS](#https)
   * [HTTPS【头条】](#https头条)
   * [HTTPS 加密验证过程：](#https-加密验证过程)
   * [抓包工具抓取HTTPS的原理【头条】](#抓包工具抓取https的原理头条)
   * [为什么Http是无状态的短连接，而TCP是有状态的长连接？Http不是建立在TCP的基础上吗，为什么还能是短连接？](#为什么http是无状态的短连接而tcp是有状态的长连接http不是建立在tcp的基础上吗为什么还能是短连接)
* [TCP和UDP](#tcp和udp)
   * [TCP和UDP的区别【阿里、百度、美团】](#tcp和udp的区别阿里百度美团)
   * [TCP头部多长，IP呢【腾讯】](#tcp头部多长ip呢腾讯)
   * [UDP可以实现一对多？【百度】](#udp可以实现一对多百度)
   * [三次握手](#三次握手)
   * [四次挥手](#四次挥手)
   * [简述TCP连接时的握手过程，不要第三次握手行不行？【头条】](#简述tcp连接时的握手过程不要第三次握手行不行头条)
   * [TCP为什么是四次挥手【头条】](#tcp为什么是四次挥手头条)
   * [TCP三次握手机制，发送的包叫啥【阿里】](#tcp三次握手机制发送的包叫啥阿里)
* [其他面试题](#其他面试题)
   * [TCP/IP五层模型](#tcpip五层模型)
   * [OSI七层模型【百度、美团】](#osi七层模型百度美团)
   * [传输层和网络层分别是做什么的【百度】](#传输层和网络层分别是做什么的百度)
   * [知道MTU吗【腾讯】](#知道mtu吗腾讯)
   * [如何维持长链接，如何发送心跳包【头条】](#如何维持长链接如何发送心跳包头条)
   * [Ping是什么协议【腾讯】](#ping是什么协议腾讯)
   * [讲了一下造成网络卡顿的原因【百度】](#讲了一下造成网络卡顿的原因百度)
   * [讲一讲拥塞控制，讲讲拥塞避免算法【腾讯、百度、头条】](#讲一讲拥塞控制讲讲拥塞避免算法腾讯百度头条)
   * [有哪些方法能加快网络连接速度【头条】](#有哪些方法能加快网络连接速度头条)
   * [介绍项目的网络层【腾讯】](#介绍项目的网络层腾讯)
* [断点续传](#断点续传)
   * [HTTP 断点续传：](#http-断点续传)
   * [IP包分片原理](#ip包分片原理)
      * [一、IP分片原理：](#一ip分片原理)
      * [二、IP分片步骤](#二ip分片步骤)
      * [三、重组](#三重组)

一个字节是 8 个比特bits

## 计算机存储单位

计算机存储单位一般用 bit, Byte, KB, MB, GB, TB, PB, EB, ZB, 宝贝老婆来表示

**1、计算机存储信息的最小单位：**
位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，最小的存储单位。 

**2、计算机存储容量基本单位是字节，也就是8个二进制位**

字节 byte：8个二进制位(bit)为一个字节(B)，最常用的单位。 (我也常说一个字节占8位)
一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。
英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占1个字节的大小，中文句号“。”占2个字节大小。

**3、他们的换算关系如下：**

* 1B  (Byte 字节)=8bit，
* 1KB (Kilobyte 千字节)=1024B， 
* 1MB (Megabyte 兆字节 简称“兆”)=1024KB， 
* 1GB (Gigabyte 吉字节 又称“千兆”)=1024MB， 
* 1TB (Trillionbyte 万亿字节 太字节)=1024GB，其中1024=2^10 ( 2 的10次方)， 
* 1PB（Petabyte 千万亿字节 拍字节）=1024TB， 
* 1EB（Exabyte 百亿亿字节 艾字节）=1024PB， 
* 1ZB (Zettabyte 十万亿亿字节 泽字节)= 1024 EB, 
* 1YB (Yottabyte 一亿亿亿字节 尧字节)= 1024 ZB, 

## HTTP

### 概念 

HTTP（HyperText Transfer Protocol）超文本传输协议是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。

* HTTP  默认的端口号为80/tcp（木马Executor开放此端口）；
* HTTPS 默认的端口号为443/tcp 443/udp；

### HTTP的特性

* HTTP构建于TCP/IP协议之上，默认端口号是80
* HTTP是无连接无状态的
* HTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE
* HTTP是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。

规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：

```
<method> <request-URL> <version>
<headers>
<entity-body>
```

### HTTP 常用状态码：

1. 1xx 消息：这一类型的状态码，代表请求已被接受，需要继续处理。
    1. 比如 Post 请求，先发送 header 数据，服务器返回100，然后再发送 data，服务器返回200
2. 2xx 成功：这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。
    1. 200 OK
    2. 206 Partial Content（RFC 7233）
        1. 服务器已经成功处理了部分GET请求。
        2. 类似于FlashGet或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。
3. 3xx 重定向：这类状态码代表需要客户端采取进一步的操作才能完成请求。
4. 4xx 客户端错误：这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。
    1. 400 Bad Request：由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。
5. 5xx 服务器错误：表示服务器无法完成明显有效的请求。[56]这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。
    1. 500 Internal Server Error：通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。

### Http1.1如1.0的区别

* **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
* **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
* **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
* **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
* **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

### Http2.0如1.x的区别【百度】

![](https://image-1258017831.cos.ap-guangzhou.myqcloud.com/20181124101405.png)

**什么是HTTP 2.0**

* HTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），是HTTP协议的的第二个主要版本，使用于万维网。
* HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。
* 注：SPDY(speedy)协议是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。

**与HTTP 1.1相比，主要区别包括：**

1. HTTP/2采用二进制格式而非文本格式
2. HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行
3. 使用报头压缩，HTTP/2降低了开销
4. HTTP/2让服务器可以将响应主动“推送”到客户端缓存中

[http1.1和http2.0区别](https://my.oschina.net/haitaohu/blog/1919894)
[http的变迁（http1.0-http2.0，https）](https://www.centos.bz/2017/09/http的变迁（http1-0-http2-0，https）/)
[SPDY、HTTP/2、QUIC协议](https://blog.csdn.net/hursing/article/details/22785475)

### 发送一个HTTP请求的过程【百度】
淘宝页面发送HTTP请求的过程【阿里】
用户产生一个下拉刷新动作，请详细描述网络如何传输【头条】

1. DNS 进行域名解析，解析出ip地址（如果是域名请求）
2. 发起TCP的3次握手，建立TCP连接
3. 发起http请求
4. 服务器响应http请求，浏览器得到html代码
5. 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）
6. 浏览器对页面进行渲染呈现给用户
7. 发起TCP的4次挥手，断开连接

[一次完整的Http请求过程](https://blog.csdn.net/zjkC050818/article/details/78345819)

### 请简述一下 DNS。【头条】

DNS（Domain Name System，域名系统），DNS 服务用于在网络请求时，将域名转为 IP 地址。能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。

* 域名系统 DNS (Domain Name System ): 作为域名和 IP 地址相互映射的一个分布式数据库，通过 DNS 可以将域名迅速解析为对应的 IP 地址，从而方便我们访问 Internet 上的任意一台主机（或网站）。
* CDN(Content Delivery Network): 其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。
* HTTPDNS: 使用 HTTP 请求来模拟 DNS 请求：为了防止传统 DNS 解析过程中出现的 DNS 劫持，DNS 缓存版本过旧，因 DNS 服务器转发功能而造成的无法精准定位用户位置的情况，于是通过使用 HTTPDNS 为主，传统DNS为辅 的机制来实现快速，实时，精准的 DNS 解析，从而提供给用户快速，安全稳定，最新的网站访问体验

DNS查找过程如下：

1. 浏览器缓存：浏览器会缓存DNS记录一段时间。 但操作系统没有告诉浏览器储存DNS记录的时间，这样不同浏览器会储存个自固定的一个时间（2分钟到30分钟不等）。
2. 系统缓存：如果在浏览器缓存里没有找到需要的域名，浏览器会做一个系统调用（windows里是gethostbyname），这样便可获得系统缓存中的记录。
3. 路由器缓存：如果系统缓存也没找到需要的域名，则会向路由器发送查询请求，它一般会有自己的DNS缓存。
4. ISP DNS缓存：如果依然没找到需要的域名，则最后要查的就是ISP缓存DNS的服务器。在这里一般都能找到相应的缓存记录。

### 有听过 HTTPDNS 吗？【头条】

HTTPDNS 利用 HTTP 协议与 DNS 服务器交互，代替了传统的基于 UDP 协议的 DNS 交互，绕开了运营商的 Local DNS，有效防止了域名劫持，提高域名解析效率。

### HTTP 有哪些部分【美团】

#### HTTP请求包含的部分
![](https://image-1258017831.cos.ap-guangzhou.myqcloud.com/20181122130232.png)

1. 请求行（request line）、
2. 请求头部（header）（Host、ser-Agent、Content-Type、Content-Length、Connection）
3. 空行
4. 请求数据四个部分组成

#### HTTP响应包含的部分
![](https://image-1258017831.cos.ap-guangzhou.myqcloud.com/20181122130333.jpg)

1. 状态行
2. 消息报头
3. 空行
4. 响应正文

### HTTP头部有哪些内容【腾讯】

**请求头部：**
1. Host
2. ser-Agent、
3. Content-Type、
4. Content-Length、
5. Connection
**响应头部：**
1. Date:生成响应的日期和时间
2. Content-Type:指定了MIME类型的HTML(text/html)
3. 编码类型是UTF-8

### HTTP 如何保证传输到达，TCP是如何保证可靠的【腾讯】

HTTP协议是建立在TCP协议基础之上的，而TCP是安全的可靠的

1. **校验和**：发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。
2. **确认应答+序列号**：TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 
3. **超时重传**：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
4. **流量控制**：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。接收方有即时窗口（滑动窗口），随ACK报文发送
5. **拥塞控制**：当网络拥塞时，减少数据的发送。发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小，慢启动、拥塞避免、拥塞发送、快速恢复
       
应用数据被分割成TCP认为最适合发送的数据块。TCP的接收端会丢弃重复的数据。  

[TCP如何保证传输可靠性](http://uule.iteye.com/blog/2429131)

TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。
发送过的数据未收到确认之前必须保留，以便超时重传时使用。发送窗口不动(没收到确认)和前移(收到新的确认)

### 为什么要使用HTTP？为什么不直接用TCP【腾讯】

TCP协议对应于传输层，而HTTP协议对应于应用层。从本质上来说，二者没有可比性。HTTP协议是建立在TCP协议基础之上的。当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。所以Http连接是一种短连接，是一种无状态的连接。

### GET 和 POST 的区别【美团】

![](https://image-1258017831.cos.ap-guangzhou.myqcloud.com/20181122131409.png)

1. GET请求可被收藏为书签，POST不能。
2. GET请求会被浏览器主动缓存，POST不会，除非手动设置。
3. GET在浏览器回退/刷新时是无害的，而POST会再次提交请求。
4. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
5. 对参数的数据类型，GET只接受ASCII字符，而POST没有限制，允许二进制。
6. 对参数数据长度的限制，GET方法URL的长度是受限制的，最大是2048个字符，POST参数数据是没有限制的。
7. GET请求只能进行url编码(application/x-www-form-urlencoded)，而POST支持多种编码方式(application/x-www-form-urlencoded 或 multipart/form-data)，可以为二进制使用多重编码。
8. POST 比 GET 更安全，因为GET参数直接暴露在URL上，POST参数在HTTP消息主体中，而且不会被保存在浏览器历史或 web 服务器日志中。

GET和POST本质上就是TCP链接，并无差别。

* GET产生一个TCP数据包；
    * 浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
* POST产生两个TCP数据包：
    * 1、浏览器先发送header，服务器响应100 continue，
    * 2、浏览器再发送data，服务器响应200 ok（返回数据）
    * 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。
* 在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。

[HTTP 中 GET 与 POST 的区别](https://www.oschina.net/news/77354/http-get-post-different)

## HTTPS

### HTTPS【头条】

![](https://image-1258017831.cos.ap-guangzhou.myqcloud.com/20181124100547.png)

HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL/TLS，因此加密的详细内容就需要SSL。

* SSL（Secure Sockets Layer） 
* TLS（Transport Layer Security）升级版本

### HTTPS 加密验证过程：

![](https://image-1258017831.cos.ap-guangzhou.myqcloud.com/20181117094004.jpeg)

1. 发起 https 请求
2. 返回服务器 crt public 证书
3. 浏览器验证 crt，不通过则报警告
4. 浏览器生成随机 key，并使用证书加密
5. 传输：证书加密过的 key
6. 服务器使用私有 crt 解密，获取 key
7. 使用 key 加密内容，然后传输给浏览器
8. 浏览器使用 key 解密获取传输内容

### 抓包工具抓取HTTPS的原理【头条】

HTTPS抓包的原理还是挺简单的，简单来说，就是Charles作为“中间人代理”，拿到了 服务器证书公钥 和 HTTPS连接的对称密钥，前提是客户端选择信任并安装Charles的CA证书，否则客户端就会“报警”并中止连接。这样看来，HTTPS还是很安全的。

Charles作为一个“中间人代理”，当浏览器和服务器通信时，Charles接收服务器的证书，但动态生成一张证书发送给浏览器，也就是说Charles作为中间代理在浏览器和服务器之间通信，所以通信的数据可以被Charles拦截并解密。由于Charles更改了证书，浏览器校验不通过会给出安全警告，必须安装Charles的证书后才能进行正常访问。

![](https://image-1258017831.cos.ap-guangzhou.myqcloud.com/20181122135939.png)

1. 客户端向服务器发起 HTTPS 请求
2. Charles 拦截客户端的请求，伪装成客户端向服务器进行请求
3. 服务器向“客户端”（实际上是Charles）返回服务器的CA证书
4. Charles 拦截服务器的响应，获取服务器证书公钥，然后自己制作一张证书，将服务器证书替换后发送给客户端。（这一步，Charles 拿到了服务器证书的公钥）
5. 客户端接收到“服务器”（实际上是Charles）的证书后，生成一个对称密钥，用 Charles 的公钥加密，发送给“服务器”（Charles）
6. Charles 拦截客户端的响应，用自己的私钥解密对称密钥，然后用服务器证书公钥加密，发送给服务器。（这一步，Charles拿到了对称密钥）
7. 服务器用自己的私钥解密对称密钥，向“客户端”（Charles）发送响应
8. Charles 拦截服务器的响应，替换成自己的证书后发送给客户端
9. 至此，连接建立，Charles拿到了服务器证书的公钥和客户端与服务器协商的对称密钥，之后就可以解密或者修改加密的报文了。

[浅谈Charles抓取HTTPS原理](https://www.jianshu.com/p/405f9d76f8c4)

### 为什么Http是无状态的短连接，而TCP是有状态的长连接？Http不是建立在TCP的基础上吗，为什么还能是短连接？

* Http就是在每次请求完成后就把TCP连接关了，所以是短连接。
* 而我们直接通过Socket编程使用TCP协议的时候，因为我们自己可以通过代码区控制什么时候打开连接什么时候关闭连接，只要我们不通过代码把连接关闭，这个连接就会在客户端和服务端的进程中一直存在，相关状态数据会一直保存着。

**Socket：**实际上Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。
Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。

## TCP和UDP

### TCP和UDP的区别【阿里、百度、美团】

**TCP**（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。
**UDP**(User Datagram Protocol用户数据报协议）是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。

1. TCP 是面向连接的传输控制协议，提供可靠的数据服务
2. UDP 提供了无链接的数据报服务//类似电话与短信
3. TCP 首部开销20字节，UDP首部开销8字节
4. TCP 逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
5. UDP 没有拥塞机制，因此网络出现拥堵不会使源主机的发送效率降低（有利于实时会议视频等）
6. TCP 的连接只能是点到点的,UDP支持一对一，多对一，多对多的交互通信

总结：

* TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。
* UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。

[TCP和UDP的区别（笔记）](https://www.jianshu.com/p/1aa25be32bfa)
[TCP和UDP的最完整的区别](https://blog.csdn.net/Li_Ning_/article/details/52117463)

### TCP头部多长，IP呢【腾讯】

* TCP首部开销20字节;
* UDP首部开销8字节;
* IP首部最长是60个字节，最小是20个字节。

![](https://image-1258017831.cos.ap-guangzhou.myqcloud.com/20181122132414.png)

* 1、为什么首部长度最小是20字节？
    * 图中每行是32bits(即4字节)，图中标识的固定部分总共有5行，所以IP首部最小是20个字节（5行*4字节每行=20字节）
* 2、为什么说首部长度最大是60个字节？
    * `首部长度是4bit，而2^4是16，所以它的取值范围是0-15(也可理解为4bit即是4个1，转换成十进制就是15)，图中每行是4个字节(32bits)，所以最大长度就是15*4=60字节。`
    * `从中也就得知首部长度最小数字是5，即1001（因为IP首部最小是20字节）。` 

[关于IP协议首部长度的计算](https://blog.csdn.net/fl_dream/article/details/78761713)

### UDP可以实现一对多？【百度】

是的，UDP 是发送报文的方式

### 三次握手

![](https://image-1258017831.cos.ap-guangzhou.myqcloud.com/20181117094119.png)

1. 首先Client端发送连接请求报文
2. Server段接受连接后回复ACK报文，并为这次连接分配资源。
3. Client端接收到ACK报文后也向Server段发送报文，并分配资源，这样TCP连接就建立了。

### 四次挥手

![](https://image-1258017831.cos.ap-guangzhou.myqcloud.com/20181117094213.png)

1. 假设Client端发起中断请求，也就是发送FIN报文。
2. Server端接到FIN报文后，意思是说“我client端要发给你了”，但是如果你还没有数据要发送完成，则不必急着关闭Socket，可以继续发送数据。所以所以你先发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。
3. 当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。
4. Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，"就知道可以断开连接了"。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！

### 简述TCP连接时的握手过程，不要第三次握手行不行？【头条】
TCP为什么是三次握手？

现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某
些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达B。本来这是一个早
已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连
接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B
发出确认，新的连接就建立了。
由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数
据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样
白白浪费了。
采用三次握手的办法可以防止.上述现象的发生。例如在刚才的情况下，A不会向B的
确认发出确认。B由于收不到确认，就知道A并没有要求建立连接。

### TCP为什么是四次挥手【头条】

理论上三次挥手也是可以的，但是需要考虑还有数据需要传输的情况，避免丢包

### TCP三次握手机制，发送的包叫啥【阿里】

syn、ack

## 其他面试题

### TCP/IP五层模型

1. 应用层 
2. 传输层 
3. 网络层 
4. 数据链路层 
5. 物理层 

没有表示层，会话层

![](https://image-1258017831.cos.ap-guangzhou.myqcloud.com/20181122143000.jpg)

[OSI七层与TCP/IP五层网络架构详解](https://www.jianshu.com/p/85af586fba54)

### OSI七层模型【百度、美团】

![](https://image-1258017831.cos.ap-guangzhou.myqcloud.com/20181122141335.gif)

1. **应用层：各种应用软件，包括 Web 应用。**
    1. OSI 的应用层协议包括文件的传输、访问及管理协议(FTAM), 以及文件虚拟终端协议(VIP)和公用管理系统信息(CMIP)等; 规定数据的传输协议；TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet
2. **表示层：数据格式标识，基本压缩加密功能。**
    1. 表示层􏰁供多种功能用于应用层数据编码和转化,以确保以一个系统应用层发送的信息可以被另一个系统应用层识别; 可以理解为：解决不同系统之间的通信，eg：Linux下的QQ和Windows下的QQ可以通信；
3. **会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。SMTP, DNS**
    1. 会话层建立、管理和终止表示层与实体之间的通信会话；建立一个连接（自动的手机信息、自动的网络寻址）;
4. **传输层：端到端传输数据的基本功能；如 TCP、UDP。**
    1. 传输层向高层􏰁提供可靠的端到端的网络数据流服务。可以理解为：每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信！常用的（TCP／UDP）协议；
5. **网络层：定义IP编址，定义路由功能；如不同设备的数据转发。IP, ICMP, ARP, RARP, AKP, UUCP**
    1. 网络层负责在源和终点之间建立连接; 可以理解为此处需要确定计算机的位置，怎么确定？IPv4，IPv6！
6. **数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。**
    1. 数据链路层通过物理网络链路􏰁供数据传输。不同的数据链路层定义了不同的网络和协 议特征,其中包括物理编址、网络拓扑结构、错误校验、数据帧序列以及流控; 可以简单的理解为：规定了0和1的分包形式，确定了网络数据包的形式；
7. **物理层：底层数据传输，如网线；网卡标准。**
    1. 物理层负责最后将信息编码成电流脉冲或其它信号用于网上传输；eg：RJ45等将数据转化成0和1；

[OSI七层模型详解](https://blog.csdn.net/yaopeng_2005/article/details/7064869)
[深入浅出－网络七层模型&&网络数据包](https://www.jianshu.com/p/4b9d43c0571a)

### 传输层和网络层分别是做什么的【百度】

* **传输层：**传输层向高层􏰁提供可靠的端到端的网络数据流服务。可以理解为：每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信！常用的（TCP／UDP）协议；
* **网络层：**网络层负责在源和终点之间建立连接; 可以理解为此处需要确定计算机的位置，怎么确定？IPv4，IPv6！

### 知道MTU吗【腾讯】

MTU值是指一种通信协议的某一层上面所能通过的最大数据报大小（以字节为单位）

### 如何维持长链接，如何发送心跳包【头条】

保活机制的：TCP 和 HTTP 都是发送心跳包来保持一个长链接

### Ping是什么协议【腾讯】

* ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。ICMP协议通过IP协议发送的，
* IP协议是一种无连接的，不可靠的数据包协议

![](https://image-1258017831.cos.ap-guangzhou.myqcloud.com/20181122143240.png)

[ping 原理与ICMP协议](https://blog.csdn.net/inject2006/article/details/2139149)

### 讲了一下造成网络卡顿的原因【百度】

链接请求增加，超过了带宽承受的压力

### 讲一讲拥塞控制，讲讲拥塞避免算法【腾讯、百度、头条】

拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。

拥塞避免算法：

1. **慢开始**( slow-start )：
    1. 当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。
2. **拥塞避免**( congestion avoidance )
    1. 让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。
3. **快重传**( fast retransmit )
    1. 快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。
    2. 发送方只要一连收到三个重复确认就应当重传对方尚未收到的报文。而不必等到该分组的重传计时器到期。
    3. 快重传算法并非取消了重传机制，只是在某些情况下更早的重传丢失的报文段（如果当发送端接收到三个重复的确认ACK时，则断定分组丢失，立即重传丢失的报文段，而不必等待重传计时器超时）。
4. **快恢复**( fast recovery )
    1. (1)当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法。
    2. (2)由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大.
    3. 1）当发送方连续收到接收方发来的三个重复确认时，就执行“乘法减小”算法，把慢开始门限减半，这是为了预防网络发生拥塞。
    4. 2）由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是把cwnd(拥塞窗口)值设置为慢开始门限减半后的值，然后开始执行拥塞避免算法，使拥塞窗口的线性增大。

[TCP的流量控制和拥塞控制](https://blog.csdn.net/yechaodechuntian/article/details/25429143)

### 有哪些方法能加快网络连接速度【头条】

1. 提高宽带带宽
2. 一个路由器内减少上网数量
3. 清除缓存：重启路由

### 介绍项目的网络层【腾讯】


## 断点续传

### HTTP 断点续传：

HTTP1.1协议（RFC2616）中定义了断点续传相关的HTTP头 Range和Content-Range字段，一个最简单的断点续传实现大概如下： 
  
1. 客户端下载一个1024K的文件，已经下载了其中512K 
2. 网络中断，客户端请求续传，因此需要在HTTP头中申明本次需要续传的片段： 
 `Range:bytes=512000-`
 这个头通知服务端从文件的512K位置开始传输文件 
3. 服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加： 
 `Content-Range:bytes 512000-/1024000` 
 并且此时服务端返回的HTTP状态码应该是206，而不是200。 

**Range**：
用于请求头中, 指定第一个字节的位置和最后一个字节的位置, 一般格式:
`Range:(unit=first byte pos)-[last byte pos]`

**Content-Range**：
用于响应头, 指定整个实体中的一部分的插入位置, 他也指示了整个实体的长度. 在服务器向客户返回一个部分响应, 它必须描述响应覆盖的范围和整个实体长度. 一般格式：
`Content-Range: bytes (unit first byte pos) - [last byte pos]/[entity legth]`

请求下载整个文件:

```
GET /test.rar HTTP/1.1
Connection: close
Host: 116.1.219.219
Range: bytes=0-801 // 一般请求下载整个文件是 bytes=0- 或不用这个头
```

一般正常回应：

```
HTTP/1.1 200 OK
Content-Length: 801
Content-Type: application/octet-stream
Content-Range: bytes 0-800/801 // 801: 文件总大小
```

### IP包分片原理

1. 数据链路层对数据帧的长度都有一个限制，也就是链路层所能承受的最大数据长度，这个值称为最大传输单元，即MTU。以以太网为例，这个值通常是1500字节。
2. 对于IP数据包来讲，也有一个长度，在IP包头中，以16位来描述IP包的长度，也就是说，一个IP包，最长可能是65535字节（多数网络设备将其限制在576字节以内）。
3. 结合以上两个概念，第一个重要的结论就出来了，如果IP包的大小，超过了MTU值，那么就需要分片，也就是把一个IP包分为多个，这个概念非常容易理解，一个载重5T的卡车，要拉10T的货，它当然就得分几次来拉了。
4. IP分片是很多资料常讲的内容，但是我倒是觉得分不分片其实不重要，重要的是另一个东西。一个数据包穿过一个大的网络，它其间会穿过多个网络，每个网络的MTU值是不同的。我们可以设想，如果接受/发送端都是以太网，它们的MTU都是1500，我们假设发送的时候，IP数据包会以1500来封装，然而，不幸的是，传输中有一段X.25网，它的MTU是576，这会发生什么呢？我想，这个才是我们所关心的。
5. 当然，结论是显而易见的，这个数据包会被再次分片，咱开始用火车拉，到了半路，不通火车，只通汽车，那一车货会被分为很多车……仅此而已，更重要的是，这种情况下，如果IP包被设置了“不允许分片标志”，那会发生些什么呢？对，数据包将被丢弃，然事收到一份ICMP（Internet Control Message Protocol，Internet控制报文协议）不可达差错，告诉你，需要分片！
6. 这个网络中最小的MTU值，被称为路径MTU，我们应该有一种有效的手段，来发现这个值，最笨的方法或许是先用traceroute查看所有节点，然后一个个ping。

　　
#### 一、IP分片原理：
![](http://oy7b0gogl.bkt.clouddn.com/F28C7C0F-B2C3-4C4A-A1CE-B4638F467FDE.png)

分片和重新组装的过程对于传输层是透明的，原因是IP数据报进行分片以后，只有它到达下一站时才可以 进行重新组装，且它是由目的端的IP层来完成的，分片之后的数据报根据需要可以再次 分片； IP分片和完整的报文差不多拥有相同的IP头,ID域对美英分片都是一致的，这样才能在进行组装的时候识别出来 同一个IP数据报文分片。在IP头里面：

* 16位识别号唯一记录了一个IP报的ID，具有同一个ID的IP分片将会重新进行组装；
* 而13位片偏移则记录了某IP片相对于整个包的位置；
* 这两个表中间的3位标志则标志着该分片后面是否还有新的分片。

这三个域组成了IP分片的所有信息，接受方可以利用这些信息对IP数据进行重新组装。

#### 二、IP分片步骤
一个未分片的数据报的分片信息字段全为0，即多个分片标志位为 0，并且偏移量 为0，分片一个数据报需要经过一下步骤：

* （1）检查DF标志位，查看是否允许分片，如果设置了该位，则数据报将被丢弃 ，并将ICMP错误返回给源端
* （2）基于MTU值，把数据字段分成两个或对个部分，除了最后的数据 部分外，所有新建的数据选项 长度必须为8字节的倍数
* （3）每个数据被放入一个IP数据报，这些数据报的包头略微改了原先的报文头
* （4）除了最后的数据报分片外，所有的分片都设置了多个分片标志位
* （5）每个分片中的片偏移量字段设为这个数据部分在原来数据报中所占的位置，这个位置相对于原来未分片数据报中的开头处。
* （6）如果在原来的数据报中包括了选项，则选项类型字节的高位字节决定了这个信息是被复制到所有分片数据报，还是只复制到第一个数据报。
* （7）设置新数据报的报文头字段及总长度字段。
* （8）重新计算报文头部校验和字段。

   此时这些分片数据报如一个完整的IP数据报一样被转发，IP独立的处理每个数据报分片，数据报分片能够通过不同的路由 ，到达目的，如果他们通过了那些规定了更小的MTU路由，还能够进一步对他们进行分片
    在目的主机上，数据被 重新组合成原来的数据报 ，发送主机设置的标示字段与数据报中的袁IP地址和目的IP地址一起使用，分片过程不改变这个字段

#### 三、重组
为了重新组合这些数据报分片，接受主机在第一个分片到达时分配一个存储缓冲区。这个主机还将启动一个计时器。当数据报的后续分片到达时，数据被复制到缓冲区存储器中片偏移量指定的位置，当所有分片都到达时，完整的未分片的原始数据报就被恢复了。
如果计时器超时并且分片保持尚未认可状态，则数据将被丢弃。这个计时器的初始值为IP数据报的生存期值，它依赖于实现的，一些实现允许对他进行配置。
重组步骤：

在接受方，一个由发送方发出的原始数据IP报，将所有的分片重新组合，才能够提交到上一层协议，每一个将被重组的IP数据报都用一个ipq结构来表示为了能够有效提高组装分片，用于保存分片的结构必须做到以下几点：

1. 快速定位某一个数据报的一组分组
2. 在属于某一个数据报的一组分片中快速插入新的分片
3. 有效的判断一个数据报的所有分片是否已经被全部接收
4. 具有重组超时机制，如果在重组完成之前超时溢出，则删除该数据报的所有内容


